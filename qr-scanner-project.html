<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="Content-Security-Policy" content="default-src 'self' 'unsafe-inline' 'unsafe-eval' https: data: blob:">
  <title>Scanner QR Code</title>
  
  <!-- Chargement de la biblioth√®que QR scanner avec plusieurs CDN de secours -->
  <script>
    // Fonction pour charger la biblioth√®que depuis un CDN
    function loadQRScannerLibrary(cdnUrl, onSuccess, onError) {
      const script = document.createElement('script');
      script.src = cdnUrl;
      script.crossOrigin = 'anonymous';
      
      script.onload = function() {
        console.log('‚úÖ Biblioth√®que charg√©e depuis:', cdnUrl);
        onSuccess();
      };
      
      script.onerror = function() {
        console.log('‚ùå √âchec de chargement depuis:', cdnUrl);
        onError();
      };
      
      document.head.appendChild(script);
    }

    // Liste des CDN √† essayer
    const cdnUrls = [
      'https://cdn.jsdelivr.net/npm/html5-qrcode@2.3.8/html5-qrcode.min.js',
      'https://unpkg.com/html5-qrcode@2.3.8/html5-qrcode.min.js',
      'https://cdnjs.cloudflare.com/ajax/libs/html5-qrcode/2.3.8/html5-qrcode.min.js',
      'https://cdn.jsdelivr.net/npm/html5-qrcode@2.3.7/html5-qrcode.min.js',
      'https://unpkg.com/html5-qrcode@2.3.7/html5-qrcode.min.js'
    ];

    let currentCdnIndex = 0;

    function tryNextCDN() {
      if (currentCdnIndex < cdnUrls.length) {
        const cdnUrl = cdnUrls[currentCdnIndex];
        console.log(`üîÑ Tentative de chargement depuis: ${cdnUrl}`);
        
        loadQRScannerLibrary(
          cdnUrl,
          function() {
            // Succ√®s - la biblioth√®que est charg√©e
            if (typeof Html5QrcodeScanner !== 'undefined') {
              console.log('‚úÖ Biblioth√®que QR scanner charg√©e avec succ√®s');
              // D√©clencher l'√©v√©nement de chargement
              window.dispatchEvent(new Event('qrLibraryLoaded'));
            } else {
              console.log('‚ö†Ô∏è Script charg√© mais Html5QrcodeScanner non d√©fini');
              tryNextCDN();
            }
          },
          function() {
            // √âchec - essayer le prochain CDN
            currentCdnIndex++;
            tryNextCDN();
          }
        );
        
        currentCdnIndex++;
      } else {
        console.error('‚ùå Tous les CDN ont √©chou√©');
        window.dispatchEvent(new Event('qrLibraryLoadFailed'));
      }
    }

    // D√©marrer le chargement
    tryNextCDN();
  </script>
  
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: linear-gradient(135deg, #1976D2 0%, #1565C0 100%);
      min-height: 100vh;
      color: #333;
    }

    .header {
      background: #1976D2;
      color: white;
      padding: 15px 20px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      box-shadow: 0 2px 10px rgba(0,0,0,0.1);
    }

    .header h1 {
      font-size: 20px;
      font-weight: bold;
    }

    .user-info {
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .logout-btn {
      background: rgba(255,255,255,0.2);
      color: white;
      border: none;
      padding: 8px 16px;
      border-radius: 20px;
      cursor: pointer;
      font-size: 14px;
      transition: all 0.3s ease;
    }

    .logout-btn:hover {
      background: rgba(255,255,255,0.3);
    }

    .container {
      max-width: 800px;
      margin: 20px auto;
      background: white;
      border-radius: 20px;
      box-shadow: 0 10px 30px rgba(0,0,0,0.1);
      overflow: hidden;
    }

    .scanner-section {
      padding: 30px;
      text-align: center;
    }

    .scanner-title {
      font-size: 24px;
      font-weight: bold;
      color: #1976D2;
      margin-bottom: 20px;
    }

    .scanner-description {
      color: #666;
      margin-bottom: 30px;
      font-size: 16px;
    }

    #reader {
      width: 100%;
      max-width: 500px;
      margin: 0 auto;
      border-radius: 15px;
      overflow: hidden;
      box-shadow: 0 5px 15px rgba(0,0,0,0.1);
    }

    .controls {
      margin: 30px 0;
    }

    .btn {
      background: #1976D2;
      color: white;
      border: none;
      padding: 12px 24px;
      border-radius: 25px;
      font-size: 16px;
      cursor: pointer;
      margin: 10px;
      transition: all 0.3s ease;
      box-shadow: 0 3px 10px rgba(25, 118, 210, 0.3);
    }

    .btn:hover {
      background: #1565C0;
      transform: translateY(-2px);
      box-shadow: 0 5px 15px rgba(25, 118, 210, 0.4);
    }

    .btn:disabled {
      background: #ccc;
      cursor: not-allowed;
      transform: none;
      box-shadow: none;
    }

    .status {
      padding: 15px;
      margin: 20px 0;
      border-radius: 10px;
      font-weight: 500;
      text-align: center;
    }

    .status.info {
      background: #E3F2FD;
      color: #1976D2;
      border: 1px solid #BBDEFB;
    }

    .status.success {
      background: #E8F5E8;
      color: #2E7D32;
      border: 1px solid #C8E6C9;
    }

    .status.error {
      background: #FFEBEE;
      color: #C62828;
      border: 1px solid #FFCDD2;
    }

    .result {
      background: #f8f9fa;
      border: 2px solid #e9ecef;
      border-radius: 15px;
      padding: 20px;
      margin: 20px 0;
      display: none;
      text-align: left;
    }

    .result.success {
      background: #E8F5E8;
      border-color: #4CAF50;
      color: #2E7D32;
    }

    .result.error {
      background: #FFEBEE;
      border-color: #F44336;
      color: #C62828;
    }

    .result.info {
      background: #E3F2FD;
      border-color: #2196F3;
      color: #1976D2;
    }

    .result-text {
      font-size: 14px;
      color: inherit;
      word-break: break-all;
      white-space: pre-wrap;
      font-family: monospace;
      margin-bottom: 15px;
      line-height: 1.5;
    }

    .btn-new-scan {
      background: #4CAF50;
      margin-top: 15px;
      border-radius: 25px;
      padding: 12px 24px;
      font-size: 16px;
      transition: all 0.3s ease;
    }

    .btn-new-scan:hover {
      background: #45a049;
      transform: translateY(-2px);
    }

    .permission-status {
      background: #f8f9fa;
      padding: 15px;
      margin: 20px 0;
      border-radius: 10px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-size: 14px;
    }

    .permission-item {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .permission-icon {
      width: 20px;
      height: 20px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 12px;
    }

    .permission-icon.granted {
      background: #4CAF50;
      color: white;
    }

    .permission-icon.denied {
      background: #F44336;
      color: white;
    }

    .loading {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 10px;
      padding: 20px;
      color: #1976D2;
    }

    .spinner {
      width: 20px;
      height: 20px;
      border: 2px solid #f3f3f3;
      border-top: 2px solid #1976D2;
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }

    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }

    @media (max-width: 768px) {
      .container {
        margin: 10px;
        border-radius: 15px;
        max-width: calc(100vw - 20px);
        overflow-x: hidden;
      }
      
      .scanner-section {
        padding: 20px;
      }
      
      .scanner-title {
        font-size: 20px;
      }
      
      .btn {
        padding: 10px 20px;
        font-size: 14px;
        margin: 5px;
      }

      /* Am√©liorations pour l'historique sur mobile */
      .history-section {
        padding: 20px;
        margin: 10px 0;
      }

      .history-controls {
        flex-direction: column;
        align-items: stretch;
        gap: 10px;
      }
      
      .search-box {
        flex-direction: column;
        width: 100%;
      }
      
      .search-input {
        min-width: auto;
        width: 100%;
      }
      
      .sort-controls {
        flex-direction: column;
        width: 100%;
      }

      .sort-select, .filter-select {
        width: 100%;
        margin-bottom: 10px;
      }

      .history-stats {
        flex-direction: column;
        gap: 10px;
      }

      .history-table-container {
        overflow-x: auto;
        -webkit-overflow-scrolling: touch;
        border-radius: 10px;
      }

      .history-table {
        min-width: 600px; /* Largeur minimale pour √©viter la compression */
        font-size: 12px;
      }

      .history-table th,
      .history-table td {
        padding: 8px 6px;
        white-space: nowrap;
      }

      /* Am√©liorations pour les boutons de diagnostic */
      .diagnostic-buttons {
        flex-direction: column;
        gap: 10px;
      }

      .diagnostic-buttons .btn {
        width: 100%;
        margin: 0;
      }

      /* Am√©liorations pour les statistiques */
      .stats-grid {
        grid-template-columns: repeat(2, 1fr);
        gap: 10px;
      }

      .stat-card {
        padding: 15px;
      }

      /* Am√©liorations pour les contr√¥les */
      .controls {
        flex-direction: column;
        gap: 10px;
      }

      .controls .btn {
        width: 100%;
        margin: 5px 0;
      }
    }

    /* Am√©liorations pour les tr√®s petits √©crans */
    @media (max-width: 480px) {
      .container {
        margin: 5px;
        border-radius: 10px;
      }

      .scanner-section {
        padding: 15px;
      }

      .history-section {
        padding: 15px;
      }

      .history-table {
        min-width: 500px;
        font-size: 11px;
      }

      .history-table th,
      .history-table td {
        padding: 6px 4px;
      }

      .btn {
        padding: 8px 16px;
        font-size: 13px;
      }

      .diagnostic-log {
        font-size: 11px;
        max-height: 150px;
      }
    }

    /* Styles pour l'historique de pointages */
    .history-section {
      background: white;
      border-radius: 20px;
      padding: 30px;
      margin: 20px 0;
      box-shadow: 0 10px 30px rgba(0,0,0,0.1);
    }

    .history-section h2 {
      color: #1976D2;
      margin-bottom: 20px;
      font-weight: bold;
    }

    .history-controls {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 20px;
      gap: 15px;
      flex-wrap: wrap;
    }

    .search-box {
      display: flex;
      gap: 10px;
      align-items: center;
    }

    .search-input {
      padding: 10px 15px;
      border: 2px solid #e1e5e9;
      border-radius: 10px;
      font-size: 14px;
      min-width: 250px;
    }

    .search-input:focus {
      border-color: #1976D2;
      box-shadow: 0 0 0 3px rgba(25, 118, 210, 0.1);
      outline: none;
    }

    .sort-controls {
      display: flex;
      gap: 10px;
      align-items: center;
    }

    .sort-select, .filter-select {
      padding: 8px 12px;
      border: 2px solid #e1e5e9;
      border-radius: 10px;
      font-size: 14px;
      background: white;
    }

    .sort-select:focus, .filter-select:focus {
      border-color: #1976D2;
      box-shadow: 0 0 0 3px rgba(25, 118, 210, 0.1);
      outline: none;
    }

    .history-stats {
      display: flex;
      gap: 20px;
      margin-bottom: 20px;
      padding: 15px;
      background: #f8f9fa;
      border-radius: 10px;
    }

    .stat-item {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .stat-label {
      font-weight: 600;
      color: #666;
    }

    .stat-value {
      font-weight: bold;
      font-size: 18px;
    }

    .stat-value.success {
      color: #4CAF50;
    }

    .stat-value.error {
      color: #F44336;
    }

    .history-table-container {
      overflow-x: auto;
      margin-bottom: 20px;
    }

    .history-table {
      width: 100%;
      border-collapse: collapse;
      background: white;
      border-radius: 10px;
      overflow: hidden;
      box-shadow: 0 2px 10px rgba(0,0,0,0.05);
    }

    .history-table th {
      background: #1976D2;
      color: white;
      padding: 15px;
      text-align: left;
      font-weight: 600;
    }

    .history-table td {
      padding: 12px 15px;
      border-bottom: 1px solid #e9ecef;
    }

    .history-table tr:hover {
      background: #f8f9fa;
    }

    .history-table .success {
      color: #4CAF50;
      font-weight: 600;
    }

    .history-table .error {
      color: #F44336;
      font-weight: 600;
    }

    .btn-small {
      padding: 5px 10px;
      margin: 0 2px;
      font-size: 12px;
      border-radius: 15px;
      background: #1976D2;
      color: white;
      border: none;
      cursor: pointer;
      transition: all 0.3s ease;
    }

    .btn-small:hover {
      background: #1565C0;
      transform: translateY(-1px);
    }

    .history-actions {
      display: flex;
      gap: 10px;
      justify-content: center;
    }

    /* Styles pour les cumuls */
    .cumuls-section {
      margin-top: 30px;
      padding: 20px;
      background: #f8f9fa;
      border-radius: 15px;
      border: 1px solid #e9ecef;
    }

    .cumuls-section h4 {
      color: #1976D2;
      margin-bottom: 20px;
      font-weight: bold;
    }

    .period-selector {
      margin-bottom: 20px;
      display: flex;
      align-items: center;
      gap: 15px;
      flex-wrap: wrap;
    }

    .period-selector label {
      font-weight: 600;
      color: #333;
    }

    .period-selector select,
    .period-selector input {
      padding: 8px 12px;
      border: 1px solid #ddd;
      border-radius: 8px;
      font-size: 14px;
    }

    .cumuls-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
      gap: 15px;
      margin-bottom: 20px;
    }

    .cumul-card {
      background: white;
      padding: 15px;
      border-radius: 10px;
      text-align: center;
      box-shadow: 0 2px 8px rgba(0,0,0,0.1);
    }

    .cumul-number {
      font-size: 20px;
      font-weight: bold;
      color: #1976D2;
      margin-bottom: 5px;
    }

    .cumul-label {
      font-size: 12px;
      color: #666;
      text-transform: uppercase;
    }

    .daily-detail {
      margin-top: 20px;
    }

    .daily-detail h5 {
      color: #1976D2;
      margin-bottom: 15px;
    }

    .daily-table-inner {
      width: 100%;
      border-collapse: collapse;
      background: white;
      border-radius: 10px;
      overflow: hidden;
      box-shadow: 0 2px 8px rgba(0,0,0,0.1);
    }

    .daily-table-inner th,
    .daily-table-inner td {
      padding: 12px;
      text-align: center;
      border-bottom: 1px solid #eee;
    }

    .daily-table-inner th {
      background: #1976D2;
      color: white;
      font-weight: 600;
    }

    .daily-table-inner tr:hover {
      background: #f5f5f5;
    }

    /* Am√©lioration du tableau principal */
    #historyTable th,
    #historyTable td {
      padding: 12px 8px;
      text-align: center;
      border-bottom: 1px solid #eee;
    }

    #historyTable th {
      background: #1976D2;
      color: white;
      font-weight: 600;
    }

    #historyTable tr:hover {
      background: #f5f5f5;
    }

    /* Styles pour les types de pointage */
    .pointage-entree {
      color: #4CAF50;
      font-weight: 600;
    }

    .pointage-sortie {
      color: #F44336;
      font-weight: 600;
    }

    /* Styles pour les messages d'avertissement */
    .status.warning {
      background: #FFF3E0;
      color: #E65100;
      border: 1px solid #FFCC02;
    }

    /* Animation pour les messages de traitement */
    .status.info {
      animation: pulse 2s infinite;
    }

    @keyframes pulse {
      0% { opacity: 1; }
      50% { opacity: 0.7; }
      100% { opacity: 1; }
    }

    /* Styles pour les indicateurs de scan */
    .scan-indicator {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(0, 0, 0, 0.8);
      color: white;
      padding: 20px;
      border-radius: 10px;
      z-index: 1000;
      display: none;
    }

    .scan-indicator.show {
      display: block;
    }

    /* Styles pour le diagnostic mobile */
    .diagnostic-section {
      background: #f8f9fa;
      border-radius: 20px;
      padding: 20px;
      margin: 20px 0;
      box-shadow: 0 10px 30px rgba(0,0,0,0.1);
    }

    .diagnostic-section h3 {
      color: #1976D2;
      margin-bottom: 15px;
      font-weight: bold;
    }

    .diagnostic-log {
      height: 200px;
      overflow-y: auto;
      border: 1px solid #e0e0e0;
      border-radius: 10px;
      padding: 10px;
      background: #f0f0f0;
      font-family: monospace;
      font-size: 14px;
      color: #333;
    }

    .log-entry {
      margin-bottom: 5px;
      padding: 5px 10px;
      border-radius: 5px;
      background: #e0e0e0;
    }

    .diagnostic-buttons {
      display: flex;
      justify-content: center;
      gap: 10px;
      flex-wrap: wrap;
    }

    /* Styles pour la section diagnostic mobile */
    .diagnostic-section {
      margin: 20px 0;
      padding: 20px;
      background: #f8f9fa;
      border-radius: 15px;
      border: 1px solid #e9ecef;
    }

    .diagnostic-section h3 {
      color: #1976D2;
      margin-bottom: 15px;
      font-weight: bold;
    }

    .diagnostic-log {
      background: #000;
      color: #00ff00;
      padding: 15px;
      border-radius: 10px;
      font-family: 'Courier New', monospace;
      font-size: 12px;
      max-height: 200px;
      overflow-y: auto;
      margin-bottom: 15px;
    }

    .log-entry {
      margin-bottom: 5px;
      padding: 2px 0;
    }

    .log-entry.success {
      color: #00ff00;
    }

    .log-entry.error {
      color: #ff0000;
    }

    .log-entry.warning {
      color: #ffff00;
    }

    .log-entry.info {
      color: #00ffff;
    }

    .diagnostic-buttons {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
    }

    .diagnostic-buttons .btn {
      flex: 1;
      min-width: 120px;
    }

    /* Styles pour les statistiques */
    .stats-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
      gap: 15px;
      margin-bottom: 20px;
    }

    .stat-card {
      background: #f8f9fa;
      padding: 20px;
      border-radius: 15px;
      text-align: center;
      border: 1px solid #e9ecef;
    }

    .stat-number {
      font-size: 24px;
      font-weight: bold;
      color: #1976D2;
      margin-bottom: 5px;
    }

    .stat-label {
      font-size: 14px;
      color: #666;
      font-weight: 500;
    }

    /* Am√©liorations pour les contr√¥les */
    .controls {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      justify-content: center;
      align-items: center;
      margin: 20px 0;
    }

    .controls .btn {
      flex: 1;
      min-width: 120px;
      max-width: 200px;
    }

    /* Am√©liorations pour les tableaux */
    .table-container {
      overflow-x: auto;
      -webkit-overflow-scrolling: touch;
      border-radius: 10px;
      margin-bottom: 20px;
    }

    /* Am√©liorations pour les √©l√©ments qui peuvent d√©border */
    .diagnostic-section {
      word-wrap: break-word;
      overflow-wrap: break-word;
    }

    .diagnostic-log {
      word-break: break-all;
      overflow-wrap: break-word;
    }

    /* Am√©liorations pour les boutons sur mobile */
    @media (max-width: 768px) {
      .controls {
        flex-direction: column;
        align-items: stretch;
      }

      .controls .btn {
        width: 100%;
        max-width: none;
        margin: 5px 0;
      }

      .stats-grid {
        grid-template-columns: repeat(2, 1fr);
        gap: 10px;
      }

      .stat-card {
        padding: 15px;
      }

      .stat-number {
        font-size: 20px;
      }

      .stat-label {
        font-size: 12px;
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="header">
      <div class="user-info">
        <span id="userDisplay">Chargement...</span>
        <button class="logout-btn" onclick="logout()">üö™ D√©connexion</button>
      </div>
    </div>

    <!-- Indicateur de scan en cours -->
    <div id="scanIndicator" class="scan-indicator">
      <div style="text-align: center;">
        <div style="font-size: 24px; margin-bottom: 10px;">‚è≥</div>
        <div id="scanMessage">Traitement en cours...</div>
      </div>
    </div>

    <!-- Section Scanner QR -->
    <div class="scanner-section">
      <h3>üì∑ Scanner QR Code</h3>
      <div id="reader"></div>
      <div id="scanStatus" class="status info">
        Scanner pr√™t - Placez le QR code dans le cadre
      </div>
      <button id="startScanButton" onclick="startScanner()" class="btn btn-success">
        üöÄ D√©marrer le Scanner
      </button>
      <button id="testScannerButton" onclick="testScanner()" class="btn btn-info">
        üß™ Tester le Scanner
      </button>
      <button id="rescanButton" onclick="startScanner()" class="btn" style="display: none;">
        üîÑ Re-scanner
      </button>
      <button id="toggleProtectionButton" onclick="toggleScanProtection()" class="btn btn-warning">
        üõ°Ô∏è D√©sactiver Protection
      </button>
      <button onclick="resetScanDelays()" class="btn btn-info">
        üîÑ R√©initialiser Codes Utilis√©s
      </button>
    </div>

    <!-- Section Historique des Pointages -->
    <div class="history-section">
      <h3>üìä Historique des Pointages</h3>
      
      <!-- Statistiques -->
      <div class="stats-grid">
        <div class="stat-card">
          <div class="stat-number" id="totalCount">0</div>
          <div class="stat-label">Total Pointages</div>
        </div>
        <div class="stat-card">
          <div class="stat-number" id="successCount">0</div>
          <div class="stat-label">Succ√®s</div>
        </div>
        <div class="stat-card">
          <div class="stat-number" id="errorCount">0</div>
          <div class="stat-label">Erreurs</div>
        </div>
        <div class="stat-card">
          <div class="stat-number" id="totalHours">0h</div>
          <div class="stat-label">Heures Prest√©es</div>
        </div>
      </div>

      <!-- Contr√¥les -->
      <div class="controls">
        <input type="text" id="searchInput" placeholder="üîç Rechercher..." class="search-input">
        <select id="sortSelect" class="sort-select">
          <option value="date">üìÖ Par Date</option>
          <option value="code">üè∑Ô∏è Par Code</option>
          <option value="status">‚úÖ Par Statut</option>
        </select>
        <select id="filterSelect" class="filter-select">
          <option value="all">üìã Tous</option>
          <option value="success">‚úÖ Succ√®s</option>
          <option value="error">‚ùå Erreurs</option>
        </select>
        <button onclick="refreshHistory()" class="btn btn-info">üîÑ Actualiser</button>
        <button onclick="loadHistoryFromDatabase()" class="btn btn-info">üì• Charger depuis DB</button>
        <button onclick="exportHistory()" class="btn btn-success">üì§ Exporter CSV</button>
        <button onclick="clearHistory()" class="btn btn-warning">ÔøΩÔøΩÔ∏è Effacer</button>
        <button onclick="forceCleanTestUserHistory()" class="btn btn-warning">
          üßπ Nettoyer SEULEMENT Test@test.com
        </button>
        <button onclick="testWithDifferentUsers()" class="btn btn-info">
          üß™ Test Utilisateurs BD
        </button>
        <button onclick="testStephaneUser()" class="btn btn-success">
          üß™ Test Stephane Banza Mutamba
        </button>
        <button onclick="testRealUserCredentials()" class="btn btn-primary">
          üîê Test Vrais Identifiants
        </button>
        <button onclick="fixHistoryDisplay()" class="btn btn-success">
          üîß Corriger Affichage Historique
        </button>
        <button onclick="forceFixHistoryDisplay()" class="btn btn-warning">
          üîß FORCER Correction Historique
        </button>
        <button onclick="cleanOtherUsersEntries()" class="btn btn-danger">
          üßπ Nettoyer Autres Utilisateurs
        </button>
        <button onclick="loadLocalHistoryOnly()" class="btn btn-success">
          ‚ö° Chargement Rapide Local
        </button>
        <button onclick="createTestEntry()" class="btn btn-primary">
          üß™ Cr√©er Entr√©e de Test
        </button>
        <button onclick="testScannerWithSimulatedQR()" class="btn btn-success">
          üì± Test Scanner QR Simul√©
        </button>
        <button onclick="forceReloadAndFindNewEntries()" class="btn btn-warning">
          üîÑ Forcer Rechargement BD
        </button>
        <button onclick="completeUserProfile()" class="btn btn-info">
          üë§ Compl√©ter Profil
        </button>
      </div>

      <!-- Tableau Historique -->
      <div class="table-container">
        <table id="historyTable">
          <thead>
            <tr>
              <th>üìÖ Date/Heure</th>
              <th>üè∑Ô∏è Code</th>
              <th>üìù D√©tails</th>
              <th>‚è∞ Type</th>
              <th>‚è±Ô∏è Heures</th>
              <th>‚úÖ Statut</th>
              <th>üëÅÔ∏è D√©tails</th>
            </tr>
          </thead>
          <tbody id="historyTableBody">
            <!-- Rempli dynamiquement -->
          </tbody>
        </table>
      </div>

      <!-- Section Cumuls -->
      <div class="cumuls-section">
        <h4>üìà Cumuls des Heures Prest√©es</h4>
        
        <!-- S√©lecteur de p√©riode -->
        <div class="period-selector">
          <label for="periodSelect">P√©riode :</label>
          <select id="periodSelect" onchange="updateCumuls()">
            <option value="current-week">üìÖ Semaine en cours</option>
            <option value="current-month">üìÖ Mois en cours</option>
            <option value="previous-month">üìÖ Mois pr√©c√©dent</option>
            <option value="custom">üìÖ P√©riode personnalis√©e</option>
          </select>
          <div id="customPeriod" style="display: none;">
            <input type="date" id="startDate" onchange="updateCumuls()">
            <input type="date" id="endDate" onchange="updateCumuls()">
          </div>
        </div>

        <!-- Statistiques cumuls -->
        <div class="cumuls-grid">
          <div class="cumul-card">
            <div class="cumul-number" id="totalHoursCumul">0h</div>
            <div class="cumul-label">Total Heures</div>
          </div>
          <div class="cumul-card">
            <div class="cumul-number" id="avgHoursPerDay">0h</div>
            <div class="cumul-label">Moyenne/Jour</div>
          </div>
          <div class="cumul-card">
            <div class="cumul-number" id="totalDays">0</div>
            <div class="cumul-label">Jours Travaill√©s</div>
          </div>
          <div class="cumul-card">
            <div class="cumul-number" id="totalSessions">0</div>
            <div class="cumul-label">Sessions</div>
          </div>
        </div>

        <!-- D√©tail par jour -->
        <div class="daily-detail">
          <h5>üìä D√©tail par Jour</h5>
          <div id="dailyDetailTable" class="daily-table">
            <!-- Rempli dynamiquement -->
          </div>
        </div>
      </div>
    </div>

    <!-- Section Diagnostic Mobile -->
    <div class="diagnostic-section">
      <h3>üîç Diagnostic Scanner</h3>
      <div id="diagnosticLog" class="diagnostic-log">
        <div class="log-entry">üì± Diagnostic d√©marr√©...</div>
      </div>
      <div class="diagnostic-buttons">
        <button onclick="runFullDiagnostic()" class="btn btn-info">
          üîç Diagnostic Complet
        </button>
        <button onclick="testQRDetection()" class="btn btn-success">
          üß™ Test D√©tection QR
        </button>
        <button onclick="testCameraPermissions()" class="btn btn-warning">
          üì∑ Test Permissions Cam√©ra
        </button>
        <button onclick="testAPIConnectivity()" class="btn btn-info">
          üåê Test Connectivit√© API
        </button>
        <button onclick="diagnoseUserEndpoints()" class="btn btn-warning">
          üîç Diagnostic Endpoints
        </button>
        <button onclick="testTimesheetEndpoint()" class="btn btn-info">
          üìä Test Endpoint Timesheet
        </button>
        <button onclick="diagnoseTimesheetData()" class="btn btn-warning">
          üîç Diagnostic Structure Donn√©es
        </button>
        <button onclick="cleanUserHistory()" class="btn btn-danger">
          üßπ Nettoyer Historique Utilisateur
        </button>
        <button onclick="clearAllHistory()" class="btn btn-danger">
          üóëÔ∏è Vider Tout l'Historique
        </button>
        <button onclick="forceCleanTestUserHistory()" class="btn btn-warning">
          üßπ Nettoyer SEULEMENT Test@test.com
        </button>
        <button onclick="testWithDifferentUsers()" class="btn btn-info">
          üß™ Test Utilisateurs BD
        </button>
        <button onclick="testStephaneUser()" class="btn btn-success">
          üß™ Test Stephane Banza Mutamba
        </button>
        <button onclick="testRealUserCredentials()" class="btn btn-primary">
          üîê Test Vrais Identifiants
        </button>
        <button onclick="fixHistoryDisplay()" class="btn btn-success">
          üîß Corriger Affichage Historique
        </button>
        <button onclick="forceFixHistoryDisplay()" class="btn btn-warning">
          üîß FORCER Correction Historique
        </button>
        <button onclick="cleanOtherUsersEntries()" class="btn btn-danger">
          üßπ Nettoyer Autres Utilisateurs
        </button>
        <button onclick="loadLocalHistoryOnly()" class="btn btn-success">
          ‚ö° Chargement Rapide Local
        </button>
        <button onclick="createTestEntry()" class="btn btn-primary">
          üß™ Cr√©er Entr√©e de Test
        </button>
        <button onclick="testScannerWithSimulatedQR()" class="btn btn-success">
          üì± Test Scanner QR Simul√©
        </button>
        <button onclick="forceReloadAndFindNewEntries()" class="btn btn-warning">
          üîÑ Forcer Rechargement BD
        </button>
        <button onclick="completeUserProfile()" class="btn btn-info">
          üë§ Compl√©ter Profil
        </button>
        <button onclick="restartScanner()" class="btn btn-info">
          üîÑ Red√©marrer Scanner
        </button>
        <button onclick="clearDiagnosticLog()" class="btn btn-warning">
          üóëÔ∏è Effacer Logs
        </button>
      </div>
    </div>
  </div>

  <script src="auth.js"></script>
  <script>
    let html5QrcodeScanner = null;
    let isScanning = false;
    let authManager = new AuthManager();

    // Variables globales pour les pointages
    let pointageHistory = [];
    let filteredHistory = [];
    let currentSession = null; // Pour tracker entr√©e/sortie

    // Variables globales pour √©viter les scans doubles
    let isProcessing = false;
    let lastScannedCode = null;
    let lastScanTime = 0;
    // Suppression du SCAN_COOLDOWN - on garde seulement la protection contre le m√™me code
    let scanProtectionEnabled = true; // Option pour d√©sactiver la protection
    let scannedCodesThisMinute = new Map(); // Stocker les codes scann√©s dans la minute courante

    // Sauvegarder l'historique dans le stockage local
    function saveHistoryToStorage() {
      localStorage.setItem('pointageHistory', JSON.stringify(pointageHistory));
    }

    // Charger l'historique depuis le stockage local
    function loadHistoryFromStorage() {
      const saved = localStorage.getItem('pointageHistory');
      pointageHistory = saved ? JSON.parse(saved) : [];
      filteredHistory = [...pointageHistory];
      updateHistoryDisplay();
      updateCumuls();
    }

    // Charger l'historique depuis le stockage local
    function loadHistory() {
      const saved = localStorage.getItem('pointageHistory');
      pointageHistory = saved ? JSON.parse(saved) : [];
      filteredHistory = [...pointageHistory];
      updateHistoryDisplay();
      updateCumuls();
    }

    // Ajouter une entr√©e √† l'historique
    function addHistoryEntry(entry) {
      // D√©terminer le type de pointage (entr√©e/sortie)
      const pointageType = determinePointageType(entry);
      
      // Cr√©er l'entr√©e avec type
      const historyEntry = {
        ...entry,
        pointageType: pointageType,
        timestamp: new Date().toISOString(),
        hoursWorked: null // Sera calcul√© si c'est une sortie
      };

      // Si c'est une sortie et qu'il y a une session en cours
      if (pointageType === 'sortie' && currentSession) {
        const hoursWorked = calculateHoursWorked(currentSession.timestamp, historyEntry.timestamp);
        historyEntry.hoursWorked = hoursWorked;
        historyEntry.sessionId = currentSession.id;
        
        // Mettre √† jour l'entr√©e d'entr√©e avec les heures
        const entryIndex = pointageHistory.findIndex(e => e.id === currentSession.id);
        if (entryIndex !== -1) {
          pointageHistory[entryIndex].hoursWorked = hoursWorked;
          pointageHistory[entryIndex].sessionEnd = historyEntry.timestamp;
        }
        
        currentSession = null; // Fin de session
      } else if (pointageType === 'entr√©e') {
        // Nouvelle session
        historyEntry.id = Date.now(); // ID unique
        currentSession = {
          id: historyEntry.id,
          timestamp: historyEntry.timestamp
        };
      }

      pointageHistory.unshift(historyEntry);
      filteredHistory = [...pointageHistory];
      
      saveHistoryToStorage();
      updateHistoryDisplay();
      updateCumuls();
    }

    // D√©terminer le type de pointage (entr√©e/sortie)
    function determinePointageType(entry) {
      // Logique bas√©e sur le code QR ou les d√©tails
      const code = typeof entry.code === 'string' ? entry.code.toLowerCase() : '';
      const details = typeof entry.details === 'string' ? entry.details.toLowerCase() : '';
      
      addDiagnosticLog(`üîç D√©termination du type de pointage pour: ${JSON.stringify(entry.code).substring(0, 100)}...`, 'info');
      
      // V√©rifier si c'est un objet JSON avec timeSheetTypeId
      if (typeof entry.code === 'object' && entry.code.timeSheetTypeId) {
        const timeSheetTypeId = entry.code.timeSheetTypeId;
        addDiagnosticLog(`üìä timeSheetTypeId d√©tect√©: ${timeSheetTypeId}`, 'info');
        // timeSheetTypeId 1 = entr√©e, 2+ = sortie
        if (timeSheetTypeId === 1) {
          addDiagnosticLog('‚úÖ Type d√©termin√©: entr√©e (timeSheetTypeId = 1)', 'success');
          return 'entr√©e';
        } else {
          addDiagnosticLog('‚úÖ Type d√©termin√©: sortie (timeSheetTypeId > 1)', 'success');
          return 'sortie';
        }
      }
      
      // V√©rifier si les d√©tails contiennent du JSON avec timeSheetTypeId
      if (entry.details) {
        try {
          const detailsObj = JSON.parse(entry.details);
          if (detailsObj.timeSheetTypeId) {
            const timeSheetTypeId = detailsObj.timeSheetTypeId;
            addDiagnosticLog(`üìä timeSheetTypeId dans d√©tails: ${timeSheetTypeId}`, 'info');
            // timeSheetTypeId 1 = entr√©e, 2+ = sortie
            if (timeSheetTypeId === 1) {
              addDiagnosticLog('‚úÖ Type d√©termin√©: entr√©e (timeSheetTypeId = 1)', 'success');
              return 'entr√©e';
            } else {
              addDiagnosticLog('‚úÖ Type d√©termin√©: sortie (timeSheetTypeId > 1)', 'success');
              return 'sortie';
            }
          }
        } catch (e) {
          // Pas de JSON valide, continuer avec la logique textuelle
          addDiagnosticLog('‚ö†Ô∏è D√©tails ne sont pas du JSON valide', 'warning');
        }
      }
      
      // Logique bas√©e sur les mots-cl√©s dans le code ou les d√©tails
      if (code.includes('entr√©e') || code.includes('in') || code.includes('start') || 
          details.includes('entr√©e') || details.includes('d√©but')) {
        addDiagnosticLog('‚úÖ Type d√©termin√©: entr√©e (mots-cl√©s)', 'success');
        return 'entr√©e';
      } else if (code.includes('sortie') || code.includes('out') || code.includes('end') || 
                 details.includes('sortie') || details.includes('fin')) {
        addDiagnosticLog('‚úÖ Type d√©termin√©: sortie (mots-cl√©s)', 'success');
        return 'sortie';
      }
      
      // Par d√©faut, alterner entr√©e/sortie
      const lastEntry = pointageHistory[0];
      if (!lastEntry || lastEntry.pointageType === 'sortie') {
        addDiagnosticLog('‚úÖ Type d√©termin√©: entr√©e (alternance par d√©faut)', 'success');
        return 'entr√©e';
      } else {
        addDiagnosticLog('‚úÖ Type d√©termin√©: sortie (alternance par d√©faut)', 'success');
        return 'sortie';
      }
    }

    // Calculer les heures travaill√©es
    function calculateHoursWorked(startTime, endTime) {
      const start = new Date(startTime);
      const end = new Date(endTime);
      const diffMs = end - start;
      const diffHours = diffMs / (1000 * 60 * 60);
      return Math.round(diffHours * 100) / 100; // Arrondir √† 2 d√©cimales
    }

    // Mettre √† jour l'affichage de l'historique
    function updateHistoryDisplay() {
      const tbody = document.getElementById('historyTableBody');
      const totalCount = document.getElementById('totalCount');
      const successCount = document.getElementById('successCount');
      const errorCount = document.getElementById('errorCount');
      const totalHours = document.getElementById('totalHours');

      // Vider le tableau
      tbody.innerHTML = '';

      // Compter les statuts
      let success = 0, error = 0, totalHoursWorked = 0;

      // Utiliser pointageHistory au lieu de filteredHistory
      const currentUser = authManager.getUser();
      const userEmail = currentUser?.email;
      const userId = currentUser?.id;
      
      // Filtrer par utilisateur connect√© - LOGIQUE AM√âLIOR√âE
      const userHistory = pointageHistory.filter(entry => {
        const entryCode = entry.code || '';
        const entryDetails = entry.details || '';
        
        // V√©rification RAPIDE : l'entr√©e appartient-elle √† l'utilisateur connect√© ?
        let isUserEntry = false;
        
        // V√©rifier si l'entr√©e contient l'email de l'utilisateur
        if (entryCode.includes(userEmail) || 
            entryDetails.includes(userEmail) ||
            entryDetails.includes('test@test.com') ||
            entryDetails.includes('Test@test.com') ||
            entryCode.includes('TEST_ENTRY') || // Pour les entr√©es de test
            entryCode.includes('QR_') || // Pour les entr√©es QR g√©n√©r√©es
            (entry.apiResponse && entry.apiResponse.createdBy === 1)) { // Pour les entr√©es cr√©√©es par l'utilisateur connect√©
          isUserEntry = true;
        }
        
        // V√©rifier aussi dans les d√©tails JSON
        try {
          const details = JSON.parse(entryDetails);
          const detailsEmail = details.un || details.userName || details.email;
          const detailsUserId = details.uid || details.userId;
          
          if (detailsEmail === userEmail || 
              detailsUserId === userId ||
              detailsUserId === userEmail) {
            isUserEntry = true;
          }
        } catch (e) {
          // Si pas de JSON valide, on garde la v√©rification pr√©c√©dente
        }
        
        return isUserEntry;
      });

      // Ajouter chaque entr√©e
      userHistory.forEach((entry, index) => {
        const date = new Date(entry.timestamp).toLocaleString('fr-FR');
        const status = entry.status || '‚úÖ Succ√®s'; // Utiliser le status de l'entr√©e ou d√©faut
        const statusClass = status.includes('Succ√®s') ? 'success' : 'error';
        const typeIcon = entry.pointageType === 'entr√©e' ? 'üü¢' : 'üî¥';
        const typeText = entry.pointageType === 'entr√©e' ? 'Entr√©e' : 'Sortie';
        const hoursText = entry.hoursWorked ? `${entry.hoursWorked}h` : '-';
        
        if (status.includes('Succ√®s')) success++;
        else error++;
        
        if (entry.hoursWorked) totalHoursWorked += entry.hoursWorked;

        // Cr√©er la ligne du tableau
        const row = document.createElement('tr');
        row.innerHTML = `
          <td>${date}</td>
          <td>${entry.code}</td>
          <td>${entry.details}</td>
          <td>${typeIcon} ${typeText}</td>
          <td>${hoursText}</td>
          <td class="${statusClass}">${status}</td>
          <td>
            <button class="btn-small" onclick="viewDetails(${index})">üëÅÔ∏è</button>
          </td>
        `;
        
        tbody.appendChild(row);
      });

      // Mettre √† jour les compteurs
      totalCount.textContent = userHistory.length;
      successCount.textContent = success;
      errorCount.textContent = error;
      totalHours.textContent = `${totalHoursWorked.toFixed(1)}h`;
    }

    // Mettre √† jour les cumuls
    function updateCumuls() {
      const periodSelect = document.getElementById('periodSelect');
      const customPeriod = document.getElementById('customPeriod');
      
      if (periodSelect.value === 'custom') {
        customPeriod.style.display = 'block';
      } else {
        customPeriod.style.display = 'none';
      }

      const { startDate, endDate } = getPeriodDates();
      const periodData = getPeriodData(startDate, endDate);
      
      updateCumulsDisplay(periodData);
      updateDailyDetail(periodData);
    }

    // Obtenir les dates de la p√©riode s√©lectionn√©e
    function getPeriodDates() {
      const periodSelect = document.getElementById('periodSelect');
      const today = new Date();
      
      switch (periodSelect.value) {
        case 'current-week':
          const startOfWeek = new Date(today);
          startOfWeek.setDate(today.getDate() - today.getDay() + 1);
          startOfWeek.setHours(0, 0, 0, 0);
          return { startDate: startOfWeek, endDate: today };
          
        case 'current-month':
          const startOfMonth = new Date(today.getFullYear(), today.getMonth(), 15);
          const endOfMonth = new Date(today.getFullYear(), today.getMonth() + 1, 16);
          return { startDate: startOfMonth, endDate: endOfMonth };
          
        case 'previous-month':
          const startOfPrevMonth = new Date(today.getFullYear(), today.getMonth() - 1, 15);
          const endOfPrevMonth = new Date(today.getFullYear(), today.getMonth(), 16);
          return { startDate: startOfPrevMonth, endDate: endOfPrevMonth };
          
        case 'custom':
          const startDate = new Date(document.getElementById('startDate').value);
          const endDate = new Date(document.getElementById('endDate').value);
          return { startDate, endDate };
          
        default:
          return { startDate: today, endDate: today };
      }
    }

    // Obtenir les donn√©es de la p√©riode
    function getPeriodData(startDate, endDate) {
      const currentUserId = authManager.getUser()?.id;
      const userHistory = pointageHistory.filter(entry => {
        if (entry.apiResponse && entry.apiResponse.userId) {
          return entry.apiResponse.userId === currentUserId;
        }
        return true;
      });

      return userHistory.filter(entry => {
        const entryDate = new Date(entry.timestamp);
        return entryDate >= startDate && entryDate <= endDate;
      });
    }

    // Mettre √† jour l'affichage des cumuls
    function updateCumulsDisplay(periodData) {
      const totalHours = periodData.reduce((sum, entry) => sum + (entry.hoursWorked || 0), 0);
      const totalSessions = periodData.filter(entry => entry.hoursWorked).length;
      const totalDays = new Set(periodData.map(entry => 
        new Date(entry.timestamp).toDateString()
      )).size;
      const avgHoursPerDay = totalDays > 0 ? totalHours / totalDays : 0;

      document.getElementById('totalHoursCumul').textContent = `${totalHours.toFixed(1)}h`;
      document.getElementById('avgHoursPerDay').textContent = `${avgHoursPerDay.toFixed(1)}h`;
      document.getElementById('totalDays').textContent = totalDays;
      document.getElementById('totalSessions').textContent = totalSessions;
    }

    // Mettre √† jour le d√©tail par jour
    function updateDailyDetail(periodData) {
      const dailyDetailTable = document.getElementById('dailyDetailTable');
      
      // Grouper par jour
      const dailyGroups = {};
      periodData.forEach(entry => {
        const date = new Date(entry.timestamp).toDateString();
        if (!dailyGroups[date]) {
          dailyGroups[date] = [];
        }
        dailyGroups[date].push(entry);
      });

      let html = '<table class="daily-table-inner">';
      html += '<thead><tr><th>Date</th><th>Entr√©es</th><th>Sorties</th><th>Heures</th></tr></thead><tbody>';
      
      Object.entries(dailyGroups).forEach(([date, entries]) => {
        const entriesCount = entries.filter(e => e.pointageType === 'entr√©e').length;
        const exitsCount = entries.filter(e => e.pointageType === 'sortie').length;
        const totalHours = entries.reduce((sum, e) => sum + (e.hoursWorked || 0), 0);
        
        html += `<tr>
          <td>${new Date(date).toLocaleDateString('fr-FR')}</td>
          <td>${entriesCount}</td>
          <td>${exitsCount}</td>
          <td>${totalHours.toFixed(1)}h</td>
        </tr>`;
      });
      
      html += '</tbody></table>';
      dailyDetailTable.innerHTML = html;
    }

    // Rechercher dans l'historique
    function searchHistory() {
      const searchTerm = document.getElementById('searchInput').value.toLowerCase();
      
      filteredHistory = pointageHistory.filter(entry => 
        entry.code.toLowerCase().includes(searchTerm) ||
        entry.details.toLowerCase().includes(searchTerm) ||
        new Date(entry.timestamp).toLocaleString('fr-FR').toLowerCase().includes(searchTerm)
      );
      
      updateHistoryDisplay();
    }

    // Trier l'historique
    function sortHistory() {
      const sortBy = document.getElementById('sortBy').value;
      
      filteredHistory.sort((a, b) => {
        switch (sortBy) {
          case 'date-desc':
            return new Date(b.timestamp) - new Date(a.timestamp);
          case 'date-asc':
            return new Date(a.timestamp) - new Date(b.timestamp);
          case 'code-asc':
            return a.code.localeCompare(b.code);
          case 'code-desc':
            return b.code.localeCompare(a.code);
          case 'status-asc':
            return (a.success === b.success) ? 0 : a.success ? -1 : 1;
          case 'status-desc':
            return (a.success === b.success) ? 0 : a.success ? 1 : -1;
          default:
            return 0;
        }
      });
      
      updateHistoryDisplay();
    }

    // Filtrer par statut
    function filterHistory() {
      const filterStatus = document.getElementById('filterStatus').value;
      
      if (filterStatus === 'all') {
        filteredHistory = [...pointageHistory];
      } else if (filterStatus === 'success') {
        filteredHistory = pointageHistory.filter(entry => entry.success);
      } else if (filterStatus === 'error') {
        filteredHistory = pointageHistory.filter(entry => !entry.success);
      }
      
      updateHistoryDisplay();
    }

    // Actualiser l'historique
    function refreshHistory() {
      loadHistoryFromStorage();
      updateStatus('üîÑ Historique actualis√©', 'success');
    }

    // Exporter l'historique en CSV
    function exportHistory() {
      if (filteredHistory.length === 0) {
        updateStatus('‚ùå Aucune donn√©e √† exporter', 'error');
        return;
      }

      let csv = 'Date,Code,D√©tails,Statut\n';
      
      filteredHistory.forEach(entry => {
        const date = new Date(entry.timestamp).toLocaleString('fr-FR');
        const status = entry.success ? 'Succ√®s' : 'Erreur';
        const details = entry.details.replace(/"/g, '""'); // √âchapper les guillemets
        
        csv += `"${date}","${entry.code}","${details}","${status}"\n`;
      });

      const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
      const link = document.createElement('a');
      const url = URL.createObjectURL(blob);
      
      link.setAttribute('href', url);
      link.setAttribute('download', `historique_pointages_${new Date().toISOString().split('T')[0]}.csv`);
      link.style.visibility = 'hidden';
      
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
      
      updateStatus('üì• Historique export√© avec succ√®s', 'success');
    }

    // Effacer l'historique
    function clearHistory() {
      if (confirm('√ätes-vous s√ªr de vouloir effacer tout l\'historique ?')) {
        pointageHistory = [];
        filteredHistory = [];
        localStorage.removeItem('pointageHistory');
        updateHistoryDisplay();
        updateStatus('üóëÔ∏è Historique effac√©', 'success');
      }
    }

    // Voir les d√©tails d'une entr√©e
    function viewDetails(index) {
      const entry = filteredHistory[index];
      if (entry) {
        alert(`D√©tails du pointage:\n\nDate: ${new Date(entry.timestamp).toLocaleString('fr-FR')}\nCode: ${entry.code}\nD√©tails: ${entry.details}\nType: ${entry.pointageType}\nHeures: ${entry.hoursWorked || '-'}\nStatut: ${entry.success ? 'Succ√®s' : 'Erreur'}`);
      }
    }

    // Synchroniser l'historique avec le serveur
    async function syncHistoryWithServer() {
      try {
        updateStatus('üîÑ Synchronisation avec le serveur...', 'info');
        
        // R√©cup√©rer l'historique depuis l'API pour l'utilisateur connect√©
        const currentUserId = authManager.getUser()?.id;
        const response = await fetch(`${authManager.API_BASE_URL}/Timesheet/Resume/UserId/${currentUserId}/scope/all`, {
          method: 'GET',
          headers: {
            'Authorization': `Bearer ${authManager.getToken()}`,
            'Content-Type': 'application/json'
          }
        });

        if (response.ok) {
          const serverHistory = await response.json();
          
          // Filtrer pour s'assurer que ce sont les donn√©es de l'utilisateur connect√©
          const userServerHistory = serverHistory.filter(item => {
            // V√©rifier si l'item appartient √† l'utilisateur connect√©
            return item.userId === currentUserId || item.createdBy === currentUserId;
          });
          
          // Convertir les donn√©es du serveur
          const convertedHistory = userServerHistory.map(item => ({
            timestamp: item.start || item.createdAt,
            code: item.code,
            details: `Planning: ${item.planningId}, Type: ${item.timesheetTypeId}`,
            success: true,
            apiResponse: item,
            serverId: item.id
          }));

          // Fusionner avec l'historique local
          const mergedHistory = mergeHistories(pointageHistory, convertedHistory);
          pointageHistory = mergedHistory;
          filteredHistory = [...pointageHistory];
          
          saveHistoryToStorage();
          updateHistoryDisplay();
          
          updateStatus(`‚úÖ Synchronisation r√©ussie: ${convertedHistory.length} entr√©es r√©cup√©r√©es`, 'success');
        } else {
          updateStatus('‚ùå Erreur lors de la synchronisation', 'error');
        }
      } catch (error) {
        console.error('Erreur synchronisation:', error);
        updateStatus('‚ùå Erreur de connexion lors de la synchronisation', 'error');
      }
    }

    // Fusionner les historiques local et serveur
    function mergeHistories(localHistory, serverHistory) {
      const merged = [...localHistory];
      
      serverHistory.forEach(serverItem => {
        // V√©rifier si l'√©l√©ment existe d√©j√† dans l'historique local
        const exists = localHistory.find(localItem => 
          localItem.code === serverItem.code || 
          localItem.serverId === serverItem.serverId
        );
        
        if (!exists) {
          merged.unshift(serverItem);
        }
      });
      
      // Trier par date (plus r√©cent en premier)
      return merged.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));
    }

    // R√©cup√©rer l'historique depuis le serveur
    async function fetchHistoryFromServer() {
      try {
        updateStatus('üîÑ R√©cup√©ration de l\'historique depuis le serveur...', 'info');
        
        const response = await fetch(`${authManager.API_BASE_URL}/Timesheet/Resume/UserId/${authManager.getUser()?.id}/scope/all`, {
          method: 'GET',
          headers: {
            'Authorization': `Bearer ${authManager.getToken()}`,
            'Content-Type': 'application/json'
          }
        });

        if (response.ok) {
          const serverHistory = await response.json();
          
          // Convertir au format local
          pointageHistory = serverHistory.map(item => ({
            timestamp: item.start || item.createdAt,
            code: item.code,
            details: `Planning: ${item.planningId}, Type: ${item.timesheetTypeId}`,
            success: true,
            apiResponse: item,
            serverId: item.id
          }));
          
          filteredHistory = [...pointageHistory];
          saveHistoryToStorage();
          updateHistoryDisplay();
          
          updateStatus(`‚úÖ Historique r√©cup√©r√©: ${pointageHistory.length} entr√©es`, 'success');
        } else {
          updateStatus('‚ùå Erreur lors de la r√©cup√©ration', 'error');
        }
      } catch (error) {
        console.error('Erreur r√©cup√©ration historique:', error);
        updateStatus('‚ùå Erreur de connexion lors de la r√©cup√©ration', 'error');
      }
    }

    // Fonction de d√©connexion
    function logout() {
      authManager.logout();
    }

    // Afficher les informations utilisateur
    function displayUserInfo() {
      const user = authManager.getUser();
      if (user) {
        const userInfo = document.getElementById('userInfo');
        const userName = document.getElementById('userName');
        userName.textContent = `üë§ ${user.username || user.name || 'Utilisateur'}`;
        userInfo.style.display = 'flex';
      }
    }

    // V√©rifier l'authentification
    async function checkAuthentication() {
      addDiagnosticLog('üîê V√©rification de l\'authentification...', 'info');
      
      if (!authManager.isAuthenticated()) {
        addDiagnosticLog('‚ùå Utilisateur non connect√© - redirection vers la page de connexion', 'error');
        updateStatus('‚ùå Veuillez vous connecter pour utiliser l\'application', 'error');
        
        // Afficher un message et un bouton de connexion
        const container = document.querySelector('.container');
        const loginMessage = document.createElement('div');
        loginMessage.style.cssText = `
          position: fixed;
          top: 50%;
          left: 50%;
          transform: translate(-50%, -50%);
          background: white;
          padding: 30px;
          border-radius: 15px;
          box-shadow: 0 10px 30px rgba(0,0,0,0.3);
          text-align: center;
          z-index: 10000;
        `;
        loginMessage.innerHTML = `
          <h3>üîê Connexion Requise</h3>
          <p>Vous devez vous connecter pour utiliser l'application.</p>
          <button onclick="window.location.href='login.html'" class="btn btn-success" style="margin: 10px;">
            üö™ Aller √† la Connexion
          </button>
          <button onclick="this.parentElement.remove()" class="btn btn-warning" style="margin: 10px;">
            ‚ùå Fermer
          </button>
        `;
        container.appendChild(loginMessage);
        
        return false;
      }

      try {
        const isValid = await authManager.validateToken();
        if (!isValid) {
          addDiagnosticLog('‚ùå Token expir√© - d√©connexion', 'error');
          authManager.logout();
          return false;
        }
        
        addDiagnosticLog('‚úÖ Authentification valid√©e', 'success');
        return true;
      } catch (error) {
        console.error('Erreur v√©rification authentification:', error);
        addDiagnosticLog(`‚ùå Erreur authentification: ${error.message}`, 'error');
        authManager.logout();
        return false;
      }
    }

    // Mettre √† jour le statut
    function updateStatus(message, type = 'info') {
      const statusDiv = document.getElementById('scanStatus');
      if (statusDiv) {
        statusDiv.textContent = message;
        statusDiv.className = `status ${type}`;
      }
      // Ajouter au log de diagnostic aussi
      addDiagnosticLog(message, type);
    }

    // V√©rifier HTTPS
    function checkHTTPS() {
      if (location.protocol !== 'https:' && location.hostname !== 'localhost' && location.hostname !== '127.0.0.1') {
        updateStatus('‚ùå HTTPS requis pour acc√©der √† la cam√©ra. Utilisez https:// ou localhost.', 'error');
        return false;
      }
      return true;
    }

    // Diagnostics
    function runDiagnostics() {
      console.log('üîç Diagnostics en cours...');
      
      // V√©rifier les permissions de cam√©ra
      if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
        console.log('‚úÖ getUserMedia support√©');
      } else {
        console.log('‚ùå getUserMedia non support√©');
      }
      
      // V√©rifier HTTPS
      if (checkHTTPS()) {
        console.log('‚úÖ HTTPS ou localhost d√©tect√©');
      } else {
        console.log('‚ùå HTTPS requis');
      }
    }

    // V√©rifier si la biblioth√®que QR est charg√©e
    function checkQRLibrary() {
      if (typeof Html5Qrcode !== 'undefined') {
        console.log('‚úÖ Biblioth√®que Html5Qrcode charg√©e');
        return true;
      } else {
        console.error('‚ùå Biblioth√®que Html5Qrcode non charg√©e');
        updateStatus('‚ùå Biblioth√®que QR scanner non charg√©e', 'error');
        return false;
      }
    }

    // Fonction pour ajouter un log de diagnostic
    function addDiagnosticLog(message, type = 'info') {
      const logDiv = document.getElementById('diagnosticLog');
      const logEntry = document.createElement('div');
      logEntry.className = `log-entry ${type}`;
      logEntry.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
      logDiv.appendChild(logEntry);
      logDiv.scrollTop = logDiv.scrollHeight;
    }

    // Diagnostic complet
    function runFullDiagnostic() {
      addDiagnosticLog('üîç D√©marrage du diagnostic complet...', 'info');
      
      // Test 1: V√©rifier la biblioth√®que
      addDiagnosticLog('üìö V√©rification de la biblioth√®que QR...', 'info');
      if (typeof Html5Qrcode !== 'undefined') {
        addDiagnosticLog('‚úÖ Biblioth√®que Html5Qrcode charg√©e', 'success');
      } else {
        addDiagnosticLog('‚ùå Biblioth√®que Html5Qrcode non charg√©e', 'error');
        return;
      }
      
      // Test 2: V√©rifier les permissions cam√©ra
      addDiagnosticLog('üì∑ V√©rification des permissions cam√©ra...', 'info');
      navigator.mediaDevices.getUserMedia({ video: true })
        .then(stream => {
          addDiagnosticLog('‚úÖ Permissions cam√©ra accord√©es', 'success');
          addDiagnosticLog(`üìπ Cam√©ra d√©tect√©e: ${stream.getVideoTracks().length} piste(s)`, 'info');
          
          // Arr√™ter le stream de test
          stream.getTracks().forEach(track => track.stop());
        })
        .catch(err => {
          addDiagnosticLog(`‚ùå Erreur permissions cam√©ra: ${err.message}`, 'error');
        });
      
      // Test 3: V√©rifier l'environnement
      addDiagnosticLog('üåê V√©rification de l\'environnement...', 'info');
      addDiagnosticLog(`üì± User Agent: ${navigator.userAgent.substring(0, 50)}...`, 'info');
      addDiagnosticLog(`üîí HTTPS: ${location.protocol === 'https:' ? 'Oui' : 'Non'}`, location.protocol === 'https:' ? 'success' : 'warning');
      addDiagnosticLog(`üìä √âcran: ${screen.width}x${screen.height}`, 'info');
      
      // Test 4: V√©rifier les √©l√©ments DOM
      addDiagnosticLog('üéØ V√©rification des √©l√©ments DOM...', 'info');
      const reader = document.getElementById('reader');
      if (reader) {
        addDiagnosticLog('‚úÖ √âl√©ment reader trouv√©', 'success');
      } else {
        addDiagnosticLog('‚ùå √âl√©ment reader manquant', 'error');
      }
      
      addDiagnosticLog('‚úÖ Diagnostic complet termin√©', 'success');
    }

    // Fonction de test de d√©tection QR
    function testQRDetection() {
      addDiagnosticLog('üß™ Test de d√©tection QR d√©marr√©...', 'info');
      
      // V√©rifier si le scanner est actif
      if (!isScanning) {
        addDiagnosticLog('‚ùå Scanner non actif - d√©marrez d\'abord le scanner', 'error');
        return;
      }
      
      // V√©rifier les permissions cam√©ra
      navigator.mediaDevices.getUserMedia({ video: true })
        .then(stream => {
          addDiagnosticLog('‚úÖ Permissions cam√©ra OK', 'success');
          addDiagnosticLog(`üìπ Cam√©ra active: ${stream.getVideoTracks().length} piste(s)`, 'info');
          
          // Tester la qualit√© de la cam√©ra
          const videoTrack = stream.getVideoTracks()[0];
          const settings = videoTrack.getSettings();
          addDiagnosticLog(`üìä R√©solution: ${settings.width}x${settings.height}`, 'info');
          addDiagnosticLog(`üéØ FPS: ${settings.frameRate || 'Non d√©fini'}`, 'info');
          
          // Arr√™ter le stream de test
          stream.getTracks().forEach(track => track.stop());
          
          addDiagnosticLog('üí° Conseils pour am√©liorer la d√©tection:', 'info');
          addDiagnosticLog('   ‚Ä¢ Assurez-vous que le QR code est bien √©clair√©', 'info');
          addDiagnosticLog('   ‚Ä¢ Maintenez le QR code stable dans le cadre', 'info');
          addDiagnosticLog('   ‚Ä¢ √âvitez les reflets sur le QR code', 'info');
          addDiagnosticLog('   ‚Ä¢ Utilisez un QR code de bonne qualit√©', 'info');
        })
        .catch(err => {
          addDiagnosticLog(`‚ùå Erreur permissions cam√©ra: ${err.message}`, 'error');
        });
    }

    // Effacer les logs de diagnostic
    function clearDiagnosticLog() {
      const logDiv = document.getElementById('diagnosticLog');
      logDiv.innerHTML = '<div class="log-entry">üì± Logs effac√©s...</div>';
    }

    // Am√©liorer la fonction testScanner pour utiliser les logs visuels
    function testScanner() {
      addDiagnosticLog('üß™ Test du scanner...', 'info');
      
      if (!checkQRLibrary()) {
        addDiagnosticLog('‚ùå Biblioth√®que QR non disponible', 'error');
        return;
      }
      
      // V√©rifier les permissions cam√©ra
      navigator.mediaDevices.getUserMedia({ video: true })
        .then(stream => {
          addDiagnosticLog('‚úÖ Permissions cam√©ra accord√©es', 'success');
          addDiagnosticLog('üìπ Cam√©ra accessible pour le scan', 'success');
          
          // Arr√™ter le stream de test
          stream.getTracks().forEach(track => track.stop());
        })
        .catch(err => {
          addDiagnosticLog(`‚ùå Erreur permissions cam√©ra: ${err.message}`, 'error');
        });
    }

    // Fonction pour red√©marrer le scanner
    function restartScanner() {
      addDiagnosticLog('üîÑ Red√©marrage du scanner...', 'info');
      
      // Arr√™ter le scanner actuel
      if (window.html5QrCode) {
        window.html5QrCode.stop().then(() => {
          addDiagnosticLog('‚úÖ Scanner arr√™t√©', 'success');
          isScanning = false;
          
          // Red√©marrer apr√®s un court d√©lai
          setTimeout(() => {
            startScanner();
          }, 1000);
        }).catch(err => {
          addDiagnosticLog(`‚ö†Ô∏è Erreur arr√™t scanner: ${err.message}`, 'warning');
          // Red√©marrer quand m√™me
          setTimeout(() => {
            startScanner();
          }, 1000);
        });
      } else {
        // Pas de scanner actif, d√©marrer directement
        startScanner();
      }
    }

    // Fonction pour tester les permissions de cam√©ra
    function testCameraPermissions() {
      addDiagnosticLog('üì∑ Test des permissions cam√©ra...', 'info');
      
      navigator.mediaDevices.getUserMedia({ 
        video: { 
          facingMode: "environment",
          width: { ideal: 640 },
          height: { ideal: 480 }
        } 
      })
      .then(stream => {
        addDiagnosticLog('‚úÖ Permissions cam√©ra accord√©es', 'success');
        addDiagnosticLog(`üìπ Cam√©ra d√©tect√©e: ${stream.getVideoTracks().length} piste(s)`, 'info');
        
        const videoTrack = stream.getVideoTracks()[0];
        const settings = videoTrack.getSettings();
        addDiagnosticLog(`üìä R√©solution: ${settings.width}x${settings.height}`, 'info');
        addDiagnosticLog(`üéØ FPS: ${settings.frameRate || 'Non d√©fini'}`, 'info');
        
        // Arr√™ter le stream de test
        stream.getTracks().forEach(track => track.stop());
        
        addDiagnosticLog('‚úÖ Cam√©ra fonctionnelle - vous pouvez d√©marrer le scanner', 'success');
      })
      .catch(err => {
        addDiagnosticLog(`‚ùå Erreur permissions cam√©ra: ${err.message}`, 'error');
        
        if (err.name === 'NotAllowedError') {
          addDiagnosticLog('üí° Solution: Autorisez l\'acc√®s √† la cam√©ra dans les param√®tres du navigateur', 'info');
        } else if (err.name === 'NotFoundError') {
          addDiagnosticLog('üí° Solution: Aucune cam√©ra d√©tect√©e sur cet appareil', 'info');
        } else if (err.name === 'NotReadableError') {
          addDiagnosticLog('üí° Solution: La cam√©ra est utilis√©e par une autre application', 'info');
        }
      });
    }

    // D√©marrer le scanner
    function startScanner() {
      const startButton = document.getElementById('startScanButton');
      const rescanButton = document.getElementById('rescanButton');
      
      // Masquer les boutons
      if (startButton) startButton.style.display = 'none';
      if (rescanButton) rescanButton.style.display = 'none';
      
      addDiagnosticLog('üîÑ Initialisation du scanner...', 'info');
      
      // Initialiser le scanner QR
      if (typeof Html5Qrcode !== 'undefined') {
        const html5QrCode = new Html5Qrcode("reader");
        
        // Configuration simplifi√©e pour mobile
        const config = {
          fps: 10,
          qrbox: { width: 250, height: 250 },
          aspectRatio: 1.0
        };
        
        // Configuration cam√©ra simplifi√©e pour mobile
        const cameraConfig = {
          facingMode: "environment"
        };
        
        addDiagnosticLog('üì∑ Configuration scanner appliqu√©e', 'info');
        
        html5QrCode.start(
          cameraConfig,
          config,
          onScanSuccess,
          onScanFailure
        ).then(() => {
          addDiagnosticLog('‚úÖ Scanner d√©marr√© avec succ√®s', 'success');
          updateStatus('üì∑ Scanner actif - Scannez un QR code', 'success');
          isScanning = true;
        }).catch(err => {
          addDiagnosticLog(`‚ùå Erreur d√©marrage scanner: ${err.message}`, 'error');
          
          // Essayer avec une configuration encore plus simple
          addDiagnosticLog('üîÑ Tentative avec configuration simplifi√©e...', 'info');
          
          const simpleConfig = {
            fps: 5,
            qrbox: { width: 200, height: 200 }
          };
          
          const simpleCameraConfig = {
            facingMode: "environment"
          };
          
          html5QrCode.start(
            simpleCameraConfig,
            simpleConfig,
            onScanSuccess,
            onScanFailure
          ).then(() => {
            addDiagnosticLog('‚úÖ Scanner d√©marr√© avec configuration simplifi√©e', 'success');
            updateStatus('üì∑ Scanner actif - Scannez un QR code', 'success');
            isScanning = true;
          }).catch(err2 => {
            addDiagnosticLog(`‚ùå √âchec m√™me avec configuration simplifi√©e: ${err2.message}`, 'error');
            updateStatus('‚ùå Erreur lors du d√©marrage du scanner: ' + err2.message, 'error');
            
            // R√©afficher les boutons en cas d'erreur
            if (startButton) startButton.style.display = 'block';
            if (rescanButton) rescanButton.style.display = 'block';
            isScanning = false;
          });
        });
        
        // Stocker l'instance pour pouvoir l'arr√™ter
        window.html5QrCode = html5QrCode;
      } else {
        addDiagnosticLog('‚ùå Biblioth√®que Html5Qrcode non disponible', 'error');
        updateStatus('‚ùå Biblioth√®que QR scanner non charg√©e', 'error');
        
        // R√©afficher les boutons en cas d'erreur
        if (startButton) startButton.style.display = 'block';
        if (rescanButton) rescanButton.style.display = 'block';
      }
    }

    // Nettoyer les codes scann√©s apr√®s un d√©lai
    function clearScannedCodes() {
      setTimeout(() => {
        lastScannedCode = null;
        addDiagnosticLog('üßπ Codes scann√©s nettoy√©s de la m√©moire', 'info');
      }, 30000); // Nettoyer apr√®s 30 secondes (au lieu de 10)
    }

    // Am√©liorer la fonction de scan pour √©viter les doubles
    function onScanSuccess(decodedText, decodedResult) {
      addDiagnosticLog(`üéØ QR Code d√©tect√©: ${decodedText.substring(0, 50)}...`, 'success');
      
      // V√©rifier si on est d√©j√† en train de traiter
      if (isProcessing) {
        addDiagnosticLog('‚è≥ Scan ignor√© - traitement en cours', 'warning');
        return;
      }

      // V√©rifier si c'est le m√™me code QR (seulement si la protection est activ√©e)
      if (scanProtectionEnabled && lastScannedCode === decodedText) {
        addDiagnosticLog('‚ö†Ô∏è Scan ignor√© - code QR d√©j√† scann√© avec succ√®s', 'warning');
        updateStatus('‚ö†Ô∏è Code QR d√©j√† utilis√© avec succ√®s - utilisez un code diff√©rent', 'warning');
        return;
      }

      // V√©rifier si le code a √©t√© scann√© dans la minute courante
      if (scanProtectionEnabled && isCodeScannedThisMinute(decodedText)) {
        addDiagnosticLog('‚ö†Ô∏è Scan ignor√© - code QR d√©j√† scann√© cette minute', 'warning');
        updateStatus('‚ö†Ô∏è Code QR d√©j√† scann√© cette minute - attendez la minute suivante', 'warning');
        return;
      }

      // Traiter le scan (ne pas marquer comme utilis√© tout de suite)
      try {
        let qrData;
        try {
          qrData = JSON.parse(decodedText);
          addDiagnosticLog('üìã QR code JSON d√©tect√©', 'info');
        } catch (e) {
          qrData = decodedText;
          addDiagnosticLog('üìã QR code texte d√©tect√©', 'info');
        }
        
        addDiagnosticLog('üîÑ Traitement du pointage...', 'info');
        validatePointage(qrData, decodedText);
      } catch (error) {
        addDiagnosticLog(`‚ùå Erreur traitement QR: ${error.message}`, 'error');
      }
    }

    // Fonction d'√©chec de scan am√©lior√©e
    function onScanFailure(error) {
      // Ne pas spammer les logs avec les erreurs normales de d√©tection
      const errorMessage = error.toString();
      if (errorMessage.includes('No MultiFormat Readers were able to detect the code')) {
        // C'est une erreur normale quand aucun QR code n'est visible
        // Ne pas logger √† chaque fois pour √©viter le spam
        return;
      }
      
      addDiagnosticLog(`‚ö†Ô∏è √âchec de scan: ${errorMessage}`, 'warning');
    }

    // Afficher l'indicateur de scan
    function showScanIndicator(message) {
      const indicator = document.getElementById('scanIndicator');
      const messageEl = document.getElementById('scanMessage');
      messageEl.textContent = message;
      indicator.classList.add('show');
    }

    // Masquer l'indicateur de scan
    function hideScanIndicator() {
      const indicator = document.getElementById('scanIndicator');
      indicator.classList.remove('show');
    }

    // Am√©liorer la fonction validatePointage avec indicateur
    async function validatePointage(qrData, originalCode) {
      // V√©rifier si on est d√©j√† en train de traiter
      if (isProcessing) {
        updateStatus('‚è≥ Traitement en cours, veuillez patienter...', 'warning');
        return;
      }

      // V√©rifier si c'est le m√™me code QR (seulement si la protection est activ√©e)
      if (scanProtectionEnabled) {
        const codeString = typeof qrData === 'string' ? qrData : JSON.stringify(qrData);
        if (lastScannedCode === codeString) {
          updateStatus('‚ö†Ô∏è Code QR d√©j√† utilis√© avec succ√®s - utilisez un code diff√©rent', 'warning');
          return;
        }
        
        // V√©rifier si le code a √©t√© scann√© dans la minute courante
        if (isCodeScannedThisMinute(originalCode)) {
          updateStatus('‚ö†Ô∏è Code QR d√©j√† scann√© cette minute - attendez la minute suivante', 'warning');
          return;
        }
      }

      // Marquer comme en traitement (mais ne pas marquer le code comme utilis√© encore)
      isProcessing = true;
      
      // Afficher l'indicateur
      showScanIndicator('Validation du pointage...');

      try {
        updateStatus('üîÑ Validation du pointage...', 'info');
        
        // D√©terminer le type de pointage
        const pointageType = determinePointageType({ 
          code: qrData, 
          details: typeof qrData === 'object' ? JSON.stringify(qrData) : 'QR Code scann√©' 
        });
        
        // V√©rifier si on peut faire ce type de pointage
        if (!canMakePointage(pointageType)) {
          updateStatus(`‚ö†Ô∏è Impossible de faire un pointage ${pointageType} maintenant`, 'warning');
          hideScanIndicator();
          isProcessing = false;
          return;
        }
        
        // Construire la payload pour l'API
        let payload;
        if (typeof qrData === 'string') {
          // Format simple
          payload = {
            code: qrData,
            details: `Pointage ${pointageType} - ${new Date().toLocaleString('fr-FR')}`,
            start: new Date().toISOString(),
            planningId: 5,
            timesheetTypeId: pointageType === 'entr√©e' ? 1 : 2 // 1=entr√©e, 2=sortie
          };
        } else if (typeof qrData === 'object') {
          // Format JSON complexe
          payload = {
            code: qrData.code || `QR_${Date.now()}`,
            details: JSON.stringify({
              ...qrData,
              pointageType: pointageType,
              timestamp: new Date().toISOString()
            }),
            start: new Date().toISOString(),
            planningId: qrData.planningId || 5,
            timesheetTypeId: pointageType === 'entr√©e' ? 1 : 2
          };
        }

        const response = await fetch(`${authManager.API_BASE_URL}/Timesheet`, {
          method: 'POST',
          headers: {
            'Authorization': `Bearer ${authManager.getToken()}`,
            'Content-Type': 'application/json'
          },
          body: JSON.stringify(payload)
        });

        if (response.ok) {
          const result = await response.json();
          
          // SEULEMENT MAINTENANT : Marquer le code comme utilis√© apr√®s succ√®s
          if (scanProtectionEnabled && originalCode) {
            lastScannedCode = originalCode;
            lastScanTime = Date.now();
            markCodeScannedThisMinute(originalCode); // Marquer pour cette minute
            addDiagnosticLog('‚úÖ Code marqu√© comme utilis√© apr√®s pointage r√©ussi', 'success');
          }
          
          // Ajouter √† l'historique avec type de pointage
          addHistoryEntry({
            timestamp: new Date().toISOString(),
            code: payload.code,
            details: `Pointage ${pointageType} - ${new Date().toLocaleString('fr-FR')}`,
            success: true,
            apiResponse: result,
            pointageType: pointageType
          });

          // Message de succ√®s am√©lior√© avec type et heure
          const typeIcon = pointageType === 'entr√©e' ? 'üü¢' : 'üî¥';
          const currentTime = new Date().toLocaleTimeString('fr-FR', { 
            hour: '2-digit', 
            minute: '2-digit' 
          });
          const successMessage = `${typeIcon} POINTAGE R√âUSSI ! ${pointageType.toUpperCase()} √† ${currentTime}`;
          
          updateStatus(successMessage, 'success');
          addDiagnosticLog(successMessage, 'success');
          
          // Afficher un message temporaire plus visible
          showSuccessMessage(successMessage);
          
          // Synchroniser avec le serveur
          if (localStorage.getItem('autoSyncEnabled') === 'true') {
            await syncHistoryWithServer();
          }
          
          // Arr√™ter le scanner apr√®s succ√®s
          stopScanner();
          
          // Afficher le bouton pour re-scanner
          document.getElementById('rescanButton').style.display = 'block';
          
        } else {
          // Am√©liorer la gestion d'erreur
          let errorText = '';
          try {
            const errorData = await response.json();
            errorText = errorData.message || errorData.error || errorData.detail || `Erreur ${response.status}`;
          } catch (e) {
            errorText = await response.text() || `Erreur ${response.status}`;
          }
          
          addDiagnosticLog(`‚ùå Erreur API: Status ${response.status} - ${errorText}`, 'error');
          updateStatus(`‚ùå Erreur lors de la validation: ${errorText}`, 'error');
          
          // Ajouter √† l'historique m√™me en cas d'erreur
          addHistoryEntry({
            timestamp: new Date().toISOString(),
            code: payload.code,
            details: `Pointage ${pointageType} - ERREUR: ${errorText}`,
            success: false,
            apiResponse: null,
            pointageType: pointageType
          });
        }
      } catch (error) {
        console.error('Erreur validation:', error);
        
        // Diagnostic d√©taill√© de l'erreur
        let errorMessage = 'Erreur de connexion lors de la validation';
        if (error.name === 'TypeError' && error.message.includes('fetch')) {
          errorMessage = 'Erreur de connexion r√©seau - v√©rifiez votre connexion internet';
        } else if (error.message.includes('Failed to fetch')) {
          errorMessage = 'Impossible de joindre le serveur - v√©rifiez votre connexion';
        } else if (error.message.includes('NetworkError')) {
          errorMessage = 'Erreur r√©seau - v√©rifiez votre connexion internet';
        } else {
          errorMessage = `Erreur: ${error.message}`;
        }
        
        updateStatus(`‚ùå ${errorMessage}`, 'error');
        addDiagnosticLog(`‚ùå Erreur r√©seau: ${error.message}`, 'error');
        
        // Ajouter √† l'historique m√™me en cas d'erreur r√©seau
        addHistoryEntry({
          timestamp: new Date().toISOString(),
          code: 'QR_ERREUR',
          details: `Pointage - ${errorMessage}`,
          success: false,
          apiResponse: null,
          pointageType: 'entr√©e' // Par d√©faut
        });
      } finally {
        // Lib√©rer le traitement et masquer l'indicateur
        isProcessing = false;
        hideScanIndicator();
      }
    }

    // V√©rifier si on peut faire un pointage de ce type
    function canMakePointage(pointageType) {
      addDiagnosticLog(`üîç V√©rification canMakePointage pour type: ${pointageType}`, 'info');
      
      const currentUserId = authManager.getUser()?.id;
      addDiagnosticLog(`üë§ Utilisateur actuel: ${currentUserId}`, 'info');
      
      const userHistory = pointageHistory.filter(entry => {
        if (entry.apiResponse && entry.apiResponse.userId) {
          return entry.apiResponse.userId === currentUserId;
        }
        return true;
      });

      addDiagnosticLog(`üìä Historique utilisateur: ${userHistory.length} entr√©es`, 'info');

      // Obtenir le dernier pointage de l'utilisateur
      const lastUserPointage = userHistory[0];
      
      if (lastUserPointage) {
        // G√©rer le cas o√π pointageType n'existe pas
        let lastPointageType = lastUserPointage.pointageType;
        if (!lastPointageType && lastUserPointage.type) {
          // Convertir le type affich√© en pointageType
          if (lastUserPointage.type.includes('Entr√©e')) {
            lastPointageType = 'entr√©e';
          } else if (lastUserPointage.type.includes('Sortie')) {
            lastPointageType = 'sortie';
          }
        }
        
        addDiagnosticLog(`üìÖ Dernier pointage: ${lastPointageType} √† ${lastUserPointage.timestamp}`, 'info');
      } else {
        addDiagnosticLog(`üìÖ Aucun pointage pr√©c√©dent trouv√©`, 'info');
      }
      
      if (pointageType === 'entr√©e') {
        // On peut faire une entr√©e si :
        // - Pas de pointage r√©cent OU
        // - Le dernier pointage √©tait une sortie
        if (!lastUserPointage) {
          addDiagnosticLog('‚úÖ Entr√©e autoris√©e: pas de pointage pr√©c√©dent', 'success');
          return true;
        }
        
        // G√©rer le cas o√π pointageType n'existe pas
        let lastPointageType = lastUserPointage.pointageType;
        if (!lastPointageType && lastUserPointage.type) {
          if (lastUserPointage.type.includes('Entr√©e')) {
            lastPointageType = 'entr√©e';
          } else if (lastUserPointage.type.includes('Sortie')) {
            lastPointageType = 'sortie';
          }
        }
        
        if (lastPointageType === 'sortie') {
          addDiagnosticLog('‚úÖ Entr√©e autoris√©e: dernier pointage √©tait sortie', 'success');
          return true;
        }
        
        // V√©rifier si le dernier pointage date de plus de 1 heure
        const lastTime = new Date(lastUserPointage.timestamp);
        const now = new Date();
        const hoursDiff = (now - lastTime) / (1000 * 60 * 60);
        
        if (hoursDiff > 1) {
          addDiagnosticLog(`‚úÖ Entr√©e autoris√©e: ${hoursDiff.toFixed(2)}h depuis le dernier pointage`, 'success');
          return true;
        } else {
          addDiagnosticLog(`‚ùå Entr√©e refus√©e: seulement ${hoursDiff.toFixed(2)}h depuis le dernier pointage`, 'error');
          return false;
        }
      } else if (pointageType === 'sortie') {
        // On peut faire une sortie si :
        // - Le dernier pointage √©tait une entr√©e
        if (!lastUserPointage) {
          addDiagnosticLog('‚ùå Sortie refus√©e: pas de pointage pr√©c√©dent', 'error');
          return false;
        }
        
        // G√©rer le cas o√π pointageType n'existe pas
        let lastPointageType = lastUserPointage.pointageType;
        if (!lastPointageType && lastUserPointage.type) {
          if (lastUserPointage.type.includes('Entr√©e')) {
            lastPointageType = 'entr√©e';
          } else if (lastUserPointage.type.includes('Sortie')) {
            lastPointageType = 'sortie';
          }
        }
        
        if (lastPointageType === 'entr√©e') {
          addDiagnosticLog('‚úÖ Sortie autoris√©e: dernier pointage √©tait entr√©e', 'success');
          return true;
        }
        
        addDiagnosticLog(`‚ùå Sortie refus√©e: dernier pointage √©tait ${lastPointageType}`, 'error');
        return false;
      }
      
      addDiagnosticLog(`‚úÖ Pointage autoris√© par d√©faut`, 'success');
      return true;
    }

    // Afficher le r√©sultat
    function showResult(message, qrCode, apiResult, type = 'info') {
      const resultDiv = document.getElementById('result');
      const resultText = document.getElementById('resultText');
      
      let resultContent = `${message}\n\n`;
      resultContent += `QR Code: ${qrCode}\n`;
      
      if (apiResult && Object.keys(apiResult).length > 0) {
        resultContent += `\nR√©ponse API: ${JSON.stringify(apiResult, null, 2)}`;
      }
      
      resultText.textContent = resultContent;
      resultDiv.style.display = 'block';
      
      // Changer la couleur selon le type
      resultDiv.className = `result ${type}`;
      
      updateStatus(message, type);
      
      // Afficher un bouton pour scanner un autre QR code
      showNewScanButton();
    }

    // Afficher le bouton pour un nouveau scan
    function showNewScanButton() {
      const resultDiv = document.getElementById('result');
      
      // Supprimer l'ancien bouton s'il existe
      const oldButton = resultDiv.querySelector('.btn-new-scan');
      if (oldButton) {
        oldButton.remove();
      }
      
      // Cr√©er le nouveau bouton
      const newScanButton = document.createElement('button');
      newScanButton.className = 'btn btn-new-scan';
      newScanButton.textContent = 'üîÑ Scanner un autre QR code';
      newScanButton.onclick = resetScanner;
      
      resultDiv.appendChild(newScanButton);
    }

    // R√©initialiser le scanner pour un nouveau scan
    function resetScanner() {
      const resultDiv = document.getElementById('result');
      resultDiv.style.display = 'none';
      
      updateStatus('Pr√™t pour un nouveau scan');
      document.getElementById('startBtn').style.display = 'block';
      
      isScanning = false;
    }

    // Arr√™ter le scanner
    function stopScanner() {
      if (window.html5QrCode) {
        window.html5QrCode.stop().then(() => {
          updateStatus('‚èπÔ∏è Scanner arr√™t√©', 'info');
          
          // Afficher le bouton re-scanner
          const rescanButton = document.getElementById('rescanButton');
          if (rescanButton) rescanButton.style.display = 'block';
        }).catch(err => {
          console.error('Erreur arr√™t scanner:', err);
        });
      }
    }

    // Initialisation de la page
    window.addEventListener('load', async function() {
      console.log('üöÄ Initialisation de la page...');
      
      // V√©rifier et afficher l'√©tat de connexion
      const isConnected = checkAndDisplayAuthStatus();
      
      // Si connect√©, compl√©ter le profil utilisateur
      if (isConnected) {
        await completeUserProfile();
      }
      
      // Charger l'historique local
      loadHistory();
      
      // Charger l'historique depuis la base de donn√©es seulement si connect√©
      if (isConnected) {
        await loadHistoryFromDatabase();
        // Test de diagnostic apr√®s chargement
        setTimeout(() => {
          testCanMakePointage();
        }, 1000);
      } else {
        addDiagnosticLog('‚ÑπÔ∏è Mode hors ligne - historique local seulement', 'info');
        updateStatus('‚ÑπÔ∏è Mode hors ligne - connectez-vous pour synchroniser', 'info');
      }
      
      // V√©rifier la biblioth√®que QR
      setTimeout(() => {
        checkQRLibrary();
      }, 1000);
      
      updateStatus('‚úÖ Page charg√©e et pr√™te', 'success');
    });

    // √âcouter l'√©v√©nement de chargement r√©ussi de la biblioth√®que
    window.addEventListener('qrLibraryLoaded', function() {
      console.log('‚úÖ √âv√©nement qrLibraryLoaded re√ßu');
      runDiagnostics();
      if (checkHTTPS()) {
        updateStatus('Pr√™t √† scanner');
        document.getElementById('startBtn').style.display = 'block';
      }
    });

    // √âcouter l'√©v√©nement d'√©chec de chargement de la biblioth√®que
    window.addEventListener('qrLibraryLoadFailed', function() {
      console.error('‚ùå √âv√©nement qrLibraryLoadFailed re√ßu');
      updateStatus('‚ùå Erreur: Impossible de charger la biblioth√®que QR scanner. V√©rifiez votre connexion internet et rechargez la page.', 'error');
    });

    // Gestion des erreurs de cam√©ra
    window.addEventListener('error', function(e) {
      if (e.message.includes('camera') || e.message.includes('permission')) {
        updateStatus('‚ùå Erreur d\'acc√®s √† la cam√©ra. V√©rifiez les permissions.', 'error');
      }
    });

    // Fonction pour d√©sactiver/activer la protection contre les scans doubles
    function toggleScanProtection() {
      scanProtectionEnabled = !scanProtectionEnabled;
      const status = scanProtectionEnabled ? 'activ√©e' : 'd√©sactiv√©e';
      addDiagnosticLog(`üõ°Ô∏è Protection codes doubles (m√™me code + m√™me minute): ${status}`, scanProtectionEnabled ? 'success' : 'warning');
      updateStatus(`üõ°Ô∏è Protection codes doubles: ${status}`, scanProtectionEnabled ? 'success' : 'warning');
      
      // Mettre √† jour le bouton
      const button = document.getElementById('toggleProtectionButton');
      if (button) {
        button.textContent = scanProtectionEnabled ? 'üõ°Ô∏è D√©sactiver Protection' : 'üõ°Ô∏è Activer Protection';
        button.className = scanProtectionEnabled ? 'btn btn-warning' : 'btn btn-success';
      }
    }

    // Fonction pour r√©initialiser les codes scann√©s
    function resetScanDelays() {
      lastScannedCode = null;
      lastScanTime = 0;
      isProcessing = false;
      scannedCodesThisMinute.clear(); // Nettoyer aussi les codes de la minute courante
      addDiagnosticLog('üîÑ Codes utilis√©s r√©initialis√©s - vous pouvez re-scanner les m√™mes codes', 'success');
      updateStatus('üîÑ Codes utilis√©s r√©initialis√©s - vous pouvez re-scanner les m√™mes codes', 'success');
    }

    // Afficher un message de succ√®s temporaire
    function showSuccessMessage(message) {
      // Cr√©er un √©l√©ment de message de succ√®s
      const successDiv = document.createElement('div');
      successDiv.className = 'success-message';
      successDiv.innerHTML = `
        <div style="
          position: fixed;
          top: 50%;
          left: 50%;
          transform: translate(-50%, -50%);
          background: #4CAF50;
          color: white;
          padding: 30px;
          border-radius: 15px;
          font-size: 18px;
          font-weight: bold;
          text-align: center;
          box-shadow: 0 10px 30px rgba(0,0,0,0.3);
          z-index: 10000;
          animation: successPulse 2s ease-in-out;
        ">
          <div style="font-size: 24px; margin-bottom: 10px;">‚úÖ</div>
          ${message}
        </div>
      `;
      
      document.body.appendChild(successDiv);
      
      // Supprimer apr√®s 3 secondes
      setTimeout(() => {
        if (successDiv.parentNode) {
          successDiv.parentNode.removeChild(successDiv);
        }
      }, 3000);
    }

    // Animation pour le message de succ√®s
    const style = document.createElement('style');
    style.textContent = `
      @keyframes successPulse {
        0% { transform: translate(-50%, -50%) scale(0.8); opacity: 0; }
        50% { transform: translate(-50%, -50%) scale(1.1); opacity: 1; }
        100% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
      }
    `;
    document.head.appendChild(style);

    // Fonction pour v√©rifier si un code a √©t√© scann√© dans la minute courante
    function isCodeScannedThisMinute(code) {
      const currentMinute = Math.floor(Date.now() / 60000); // Minute courante
      const codeInfo = scannedCodesThisMinute.get(code);
      
      if (codeInfo && codeInfo.minute === currentMinute) {
        return true;
      }
      
      return false;
    }

    // Fonction pour marquer un code comme scann√© dans la minute courante
    function markCodeScannedThisMinute(code) {
      const currentMinute = Math.floor(Date.now() / 60000);
      scannedCodesThisMinute.set(code, {
        minute: currentMinute,
        timestamp: Date.now()
      });
      
      // Nettoyer les anciennes entr√©es (plus de 2 minutes)
      const twoMinutesAgo = currentMinute - 2;
      for (const [key, value] of scannedCodesThisMinute.entries()) {
        if (value.minute < twoMinutesAgo) {
          scannedCodesThisMinute.delete(key);
        }
      }
    }

    // Fonction pour tester la connectivit√© API
    async function testAPIConnectivity() {
      addDiagnosticLog('üåê Test de connectivit√© API...', 'info');
      
      try {
        // Test 1: Connectivit√© de base
        addDiagnosticLog('üì° Test 1: Connectivit√© de base...', 'info');
        const baseResponse = await fetch(`${authManager.API_BASE_URL}/Auth/login`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ Email: 'test@test.com', password: 'test' })
        });
        
        addDiagnosticLog(`‚úÖ Connectivit√© de base: Status ${baseResponse.status}`, 'success');
        
        // Test 2: Authentification
        addDiagnosticLog('üîê Test 2: Authentification...', 'info');
        const token = authManager.getToken();
        addDiagnosticLog(`‚úÖ Token pr√©sent: ${token ? 'Oui' : 'Non'}`, 'info');
        
        // Test 3: Endpoint Timesheet
        addDiagnosticLog('üìä Test 3: Endpoint Timesheet...', 'info');
        try {
          const timesheetResponse = await fetch(`${authManager.API_BASE_URL}/Timesheet`, {
            headers: {
              'Authorization': `Bearer ${token}`,
              'Content-Type': 'application/json'
            }
          });
          
          if (timesheetResponse.ok) {
            const timesheetData = await timesheetResponse.json();
            addDiagnosticLog(`‚úÖ Timesheet accessible: ${timesheetData.length || 0} entr√©es`, 'success');
          } else {
            addDiagnosticLog(`‚ùå Timesheet inaccessible: ${timesheetResponse.status}`, 'error');
          }
        } catch (error) {
          addDiagnosticLog(`‚ùå Erreur test connectivit√©: ${error.message}`, 'error');
          addDiagnosticLog('üí° Solution: V√©rifiez votre connexion internet', 'info');
        }
        
      } catch (error) {
        addDiagnosticLog(`‚ùå Erreur test connectivit√©: ${error.message}`, 'error');
      }
    }

    // Fonction am√©lior√©e pour diagnostiquer l'environnement
    function diagnoseEnvironment() {
      addDiagnosticLog('üîç D√©marrage du diagnostic complet...', 'info');
      
      // Test 1: V√©rifier la biblioth√®que QR
      addDiagnosticLog('üìö V√©rification de la biblioth√®que QR...', 'info');
      if (typeof Html5Qrcode !== 'undefined') {
        addDiagnosticLog('‚úÖ Biblioth√®que Html5Qrcode charg√©e', 'success');
      } else {
        addDiagnosticLog('‚ùå Biblioth√®que Html5Qrcode non charg√©e', 'error');
        return;
      }
      
      // Test 2: V√©rifier les permissions cam√©ra
      addDiagnosticLog('üì∑ V√©rification des permissions cam√©ra...', 'info');
      navigator.mediaDevices.getUserMedia({ video: true })
        .then(stream => {
          addDiagnosticLog('‚úÖ Permissions cam√©ra accord√©es', 'success');
          addDiagnosticLog(`üìπ Cam√©ra d√©tect√©e: ${stream.getVideoTracks().length} piste(s)`, 'info');
          
          // Arr√™ter le stream de test
          stream.getTracks().forEach(track => track.stop());
        })
        .catch(err => {
          addDiagnosticLog(`‚ùå Erreur permissions cam√©ra: ${err.message}`, 'error');
        });
      
      // Test 3: V√©rifier l'environnement avec d√©tection HTTPS am√©lior√©e
      addDiagnosticLog('üåê V√©rification de l\'environnement...', 'info');
      addDiagnosticLog(`üì± User Agent: ${navigator.userAgent.substring(0, 50)}...`, 'info');
      
      // D√©tection HTTPS am√©lior√©e
      const isHTTPS = location.protocol === 'https:' || 
                      location.hostname === 'localhost' || 
                      location.hostname === '127.0.0.1' ||
                      location.hostname.includes('localhost');
      
      addDiagnosticLog(`üîí HTTPS: ${isHTTPS ? 'Oui' : 'Non'}`, isHTTPS ? 'success' : 'warning');
      
      if (!isHTTPS && location.hostname !== 'localhost' && location.hostname !== '127.0.0.1') {
        addDiagnosticLog('‚ö†Ô∏è Attention: HTTPS recommand√© pour la cam√©ra sur mobile', 'warning');
        addDiagnosticLog('üí° Solution: D√©ployez sur un serveur HTTPS', 'info');
      }
      
      addDiagnosticLog(`üìä √âcran: ${screen.width}x${screen.height}`, 'info');
      
      // Test 4: V√©rifier les √©l√©ments DOM
      addDiagnosticLog('üéØ V√©rification des √©l√©ments DOM...', 'info');
      const reader = document.getElementById('reader');
      if (reader) {
        addDiagnosticLog('‚úÖ √âl√©ment reader trouv√©', 'success');
      } else {
        addDiagnosticLog('‚ùå √âl√©ment reader manquant', 'error');
      }
      
      addDiagnosticLog('‚úÖ Diagnostic complet termin√©', 'success');
    }

    // Fonction am√©lior√©e pour filtrer les donn√©es utilisateur
    function filterUserData(allEntries, currentUser) {
      addDiagnosticLog(`üîç Filtrage des donn√©es pour: ${currentUser}`, 'info');
      
      if (!allEntries || allEntries.length === 0) {
        addDiagnosticLog('‚ÑπÔ∏è Aucune donn√©e √† filtrer', 'info');
        return [];
      }
      
      const userEntries = [];
      let foundByEmail = 0;
      let foundById = 0;
      let foundByUsername = 0;
      let foundInDetails = 0;
      
      for (const entry of allEntries) {
        let isUserEntry = false;
        
        // V√©rifier par email
        if (entry.userEmail && entry.userEmail.toLowerCase() === currentUser.toLowerCase()) {
          userEntries.push(entry);
          foundByEmail++;
          isUserEntry = true;
        }
        
        // V√©rifier par ID utilisateur
        if (!isUserEntry && entry.userId && entry.userId.toString() === currentUser) {
          userEntries.push(entry);
          foundById++;
          isUserEntry = true;
        }
        
        // V√©rifier par username
        if (!isUserEntry && entry.userName && entry.userName.toLowerCase() === currentUser.toLowerCase()) {
          userEntries.push(entry);
          foundByUsername++;
          isUserEntry = true;
        }
        
        // V√©rifier dans les d√©tails JSON
        if (!isUserEntry && entry.details) {
          try {
            const details = JSON.parse(entry.details);
            if (details.un && details.un.toLowerCase() === currentUser.toLowerCase()) {
              userEntries.push(entry);
              foundInDetails++;
              isUserEntry = true;
            }
          } catch (e) {
            // Ignorer les d√©tails non-JSON
          }
        }
      }
      
      addDiagnosticLog(`üìä R√©sultats filtrage:`, 'info');
      addDiagnosticLog(`   ‚Ä¢ Par email: ${foundByEmail}`, 'info');
      addDiagnosticLog(`   ‚Ä¢ Par ID: ${foundById}`, 'info');
      addDiagnosticLog(`   ‚Ä¢ Par username: ${foundByUsername}`, 'info');
      addDiagnosticLog(`   ‚Ä¢ Dans d√©tails: ${foundInDetails}`, 'info');
      addDiagnosticLog(`   ‚Ä¢ Total: ${userEntries.length}`, 'info');
      
      return userEntries;
    }

    // Fonction am√©lior√©e pour charger l'historique avec meilleur filtrage
    async function loadHistoryOptimized() {
      addDiagnosticLog('üì• Chargement OPTIMIS√â de l\'historique...', 'info');
      
      try {
        const currentUser = authManager.getUser()?.email || authManager.getUser()?.username || 'Test@test.com';
        addDiagnosticLog(`üë§ Chargement pour l'utilisateur: ${currentUser}`, 'info');
        
        const response = await fetch(`${authManager.API_BASE_URL}/Timesheet`, {
          headers: authManager.getAuthHeaders()
        });
        
        if (response.ok) {
          const allEntries = await response.json();
          addDiagnosticLog(`‚úÖ ${allEntries.length} entr√©es r√©cup√©r√©es depuis: ${authManager.API_BASE_URL}/Timesheet`, 'success');
          
          // Utiliser la fonction de filtrage am√©lior√©e
          const userEntries = filterUserData(allEntries, currentUser);
          
          if (userEntries.length > 0) {
            addDiagnosticLog(`üìã Entr√©es trouv√©es:`, 'info');
            userEntries.slice(0, 10).forEach((entry, index) => {
              addDiagnosticLog(`${index + 1}. ID:${entry.id}, Code:${entry.code}, Created:${entry.createdAt}`, 'info');
            });
            if (userEntries.length > 10) {
              addDiagnosticLog(`... et ${userEntries.length - 10} autres`, 'info');
            }
            
            // Convertir les entr√©es au format attendu
            const convertedHistory = userEntries.map((entry, index) => {
              let type = 'üü¢ Entr√©e';
              let pointageType = 'entr√©e';
              
              try {
                const details = JSON.parse(entry.details || '{}');
                const timeSheetTypeId = details.timeSheetTypeId || entry.timesheetTypeId;
                const pid = details.pid || entry.planningId;
                
                if (timeSheetTypeId === 1) {
                  type = 'üü¢ Entr√©e';
                  pointageType = 'entr√©e';
                } else if (timeSheetTypeId === 2 || timeSheetTypeId === 3 || timeSheetTypeId === 6 || timeSheetTypeId === 8 || timeSheetTypeId === 9) {
                  type = 'üî¥ Sortie';
                  pointageType = 'sortie';
                } else if (pid === 6 || pid === 8 || pid === 9 || pid === 10) {
                  type = 'üî¥ Sortie';
                  pointageType = 'sortie';
                } else {
                  // Si pas d'indication claire, utiliser l'alternance
                  if (index % 2 === 0) {
                    type = 'üü¢ Entr√©e';
                    pointageType = 'entr√©e';
                  } else {
                    type = 'üî¥ Sortie';
                    pointageType = 'sortie';
                  }
                }
              } catch (e) {
                // Si pas de JSON valide, utiliser l'alternance
                if (index % 2 === 0) {
                  type = 'üü¢ Entr√©e';
                  pointageType = 'entr√©e';
                } else {
                  type = 'üî¥ Sortie';
                  pointageType = 'sortie';
                }
              }
              
              return {
                timestamp: new Date(entry.start || entry.createdAt || Date.now()),
                code: entry.code || 'UNKNOWN',
                details: entry.details || JSON.stringify(entry),
                type: type,
                pointageType: pointageType,
                hours: '-',
                status: '‚úÖ Succ√®s',
                apiResponse: entry
              };
            });
            
            // Remplacer compl√®tement l'historique local
            pointageHistory = convertedHistory;
            saveHistoryToStorage();
            updateHistoryDisplay();
            
            addDiagnosticLog(`‚úÖ ${convertedHistory.length} entr√©es ajout√©es √† l'historique`, 'success');
          } else {
            addDiagnosticLog('‚ÑπÔ∏è Aucune entr√©e trouv√©e pour cet utilisateur', 'info');
            // Nettoyer l'historique si aucune entr√©e trouv√©e
            pointageHistory = [];
            saveHistoryToStorage();
            updateHistoryDisplay();
          }
        } else {
          addDiagnosticLog(`‚ùå Erreur r√©cup√©ration historique: ${await response.text()}`, 'error');
        }
        
      } catch (error) {
        addDiagnosticLog(`‚ùå Erreur lors du chargement: ${error.message}`, 'error');
      }
    }

    // Afficher les informations utilisateur
    function updateUserDisplay() {
      const userDisplay = document.getElementById('userDisplay');
      if (userDisplay) {
        if (authManager.isAuthenticated()) {
          const user = authManager.getUser();
          userDisplay.textContent = `üë§ ${user?.username || user?.email || 'Utilisateur'} (Connect√©)`;
          userDisplay.style.color = '#4CAF50';
        } else {
          userDisplay.textContent = '‚ùå Non connect√©';
          userDisplay.style.color = '#F44336';
        }
      }
    }

    // Fonction pour v√©rifier et afficher l'√©tat de connexion
    function checkAndDisplayAuthStatus() {
      addDiagnosticLog('üîç V√©rification de l\'√©tat de connexion...', 'info');
      
      if (authManager.isAuthenticated()) {
        const user = authManager.getUser();
        addDiagnosticLog(`‚úÖ Utilisateur connect√©: ${user?.username || user?.email || 'ID: ' + user?.id}`, 'success');
        updateUserDisplay();
        return true;
      } else {
        addDiagnosticLog('‚ùå Aucun utilisateur connect√©', 'error');
        updateUserDisplay();
        return false;
      }
    }

    // Fonction pour compl√©ter le profil utilisateur
    async function completeUserProfile() {
      addDiagnosticLog('üë§ Compl√©tion du profil utilisateur...', 'info');
      
      try {
        const user = authManager.getUser();
        
        // Si l'utilisateur a d√©j√† un ID, on l'utilise
        if (user && user.id) {
          addDiagnosticLog(`‚úÖ Profil utilisateur d√©j√† complet: ID ${user.id}`, 'success');
          return true;
        }
        
        // Sinon, on utilise l'email comme ID (fallback)
        if (user && user.email) {
          addDiagnosticLog(`üîÑ Utilisation de l'email comme ID: ${user.email}`, 'info');
          
          // Mettre √† jour l'utilisateur avec l'email comme ID
          const updatedUser = {
            ...user,
            id: user.email
          };
          
          // Mettre √† jour dans authManager
          authManager.user = updatedUser;
          localStorage.setItem('user', JSON.stringify(updatedUser));
          
          addDiagnosticLog(`‚úÖ Profil utilisateur mis √† jour avec ID: ${updatedUser.id}`, 'success');
          return true;
        }
        
        // Si pas d'email, on utilise le token comme identifiant
        const token = authManager.getToken();
        if (token) {
          addDiagnosticLog('üîÑ Utilisation du token comme identifiant', 'info');
          
          const updatedUser = {
            ...user,
            id: 'user_' + Date.now(), // ID temporaire bas√© sur le timestamp
            email: user?.email || 'Test@test.com'
          };
          
          authManager.user = updatedUser;
          localStorage.setItem('user', JSON.stringify(updatedUser));
          
          addDiagnosticLog(`‚úÖ Profil utilisateur cr√©√© avec ID temporaire: ${updatedUser.id}`, 'success');
          return true;
        }
        
        addDiagnosticLog('‚ùå Impossible de cr√©er un profil utilisateur', 'error');
        return false;
        
      } catch (error) {
        addDiagnosticLog(`‚ùå Erreur compl√©tion profil: ${error.message}`, 'error');
        return false;
      }
    }

    // Fonction pour diagnostiquer les endpoints utilisateur
    async function diagnoseUserEndpoints() {
      addDiagnosticLog('üîç Diagnostic des endpoints utilisateur...', 'info');
      
      try {
        const token = authManager.getToken();
        const user = authManager.getUser();
        
        addDiagnosticLog(`üîë Token pr√©sent: ${token ? 'Oui' : 'Non'}`, 'info');
        addDiagnosticLog(`üë§ Utilisateur stock√©: ${JSON.stringify(user)}`, 'info');
        
        // Test 1: Endpoint /me
        addDiagnosticLog('üì° Test 1: Endpoint /me...', 'info');
        try {
          const response1 = await fetch(`${authManager.API_BASE_URL}/Auth/users/me`, {
            headers: {
              'Authorization': `Bearer ${token}`,
              'Content-Type': 'application/json'
            }
          });
          
          addDiagnosticLog(`üì° /me - Status: ${response1.status}`, response1.ok ? 'success' : 'error');
          
          if (response1.ok) {
            const data1 = await response1.json();
            addDiagnosticLog(`‚úÖ /me - Donn√©es: ${JSON.stringify(data1)}`, 'success');
          } else {
            const error1 = await response1.text();
            addDiagnosticLog(`‚ùå /me - Erreur: ${error1}`, 'error');
          }
        } catch (error) {
          addDiagnosticLog(`‚ùå /me - Exception: ${error.message}`, 'error');
        }
        
        // Test 2: Endpoint avec ID utilisateur
        if (user && user.id) {
          addDiagnosticLog(`üì° Test 2: Endpoint /users/${user.id}...`, 'info');
          try {
            const response2 = await fetch(`${authManager.API_BASE_URL}/Auth/users/${user.id}`, {
              headers: {
                'Authorization': `Bearer ${token}`,
                'Content-Type': 'application/json'
              }
            });
            
            addDiagnosticLog(`üì° /users/${user.id} - Status: ${response2.status}`, response2.ok ? 'success' : 'error');
            
            if (response2.ok) {
              const data2 = await response2.json();
              addDiagnosticLog(`‚úÖ /users/${user.id} - Donn√©es: ${JSON.stringify(data2)}`, 'success');
            } else {
              const error2 = await response2.text();
              addDiagnosticLog(`‚ùå /users/${user.id} - Erreur: ${error2}`, 'error');
            }
          } catch (error) {
            addDiagnosticLog(`‚ùå /users/${user.id} - Exception: ${error.message}`, 'error');
          }
        }
        
        // Test 3: Endpoint Auth g√©n√©ral
        addDiagnosticLog('üì° Test 3: Endpoint /Auth...', 'info');
        try {
          const response3 = await fetch(`${authManager.API_BASE_URL}/Auth`, {
            headers: {
              'Authorization': `Bearer ${token}`,
              'Content-Type': 'application/json'
            }
          });
          
          addDiagnosticLog(`üì° /Auth - Status: ${response3.status}`, response3.ok ? 'success' : 'error');
          
          if (response3.ok) {
            const data3 = await response3.json();
            addDiagnosticLog(`‚úÖ /Auth - Donn√©es: ${JSON.stringify(data3)}`, 'success');
          } else {
            const error3 = await response3.text();
            addDiagnosticLog(`‚ùå /Auth - Erreur: ${error3}`, 'error');
          }
        } catch (error) {
          addDiagnosticLog(`‚ùå /Auth - Exception: ${error.message}`, 'error');
        }
        
      } catch (error) {
        addDiagnosticLog(`‚ùå Erreur diagnostic endpoints: ${error.message}`, 'error');
      }
    }

    // Fonction pour tester l'endpoint Timesheet
    async function testTimesheetEndpoint() {
      addDiagnosticLog('üìä Test de l\'endpoint Timesheet...', 'info');
      
      try {
        const token = authManager.getToken();
        const user = authManager.getUser();
        
        addDiagnosticLog(`üë§ Utilisateur: ${user?.email || user?.id}`, 'info');
        
        // Test 1: Endpoint simple Timesheet
        addDiagnosticLog('üì° Test 1: GET /Timesheet', 'info');
        try {
          const response1 = await fetch(`${authManager.API_BASE_URL}/Timesheet`, {
            headers: {
              'Authorization': `Bearer ${token}`,
              'Content-Type': 'application/json'
            }
          });
          
          addDiagnosticLog(`üì° GET /Timesheet - Status: ${response1.status}`, response1.ok ? 'success' : 'error');
          
          if (response1.ok) {
            const data1 = await response1.json();
            addDiagnosticLog(`‚úÖ GET /Timesheet - ${Array.isArray(data1) ? data1.length : 1} entr√©e(s)`, 'success');
          } else {
            const error1 = await response1.text();
            addDiagnosticLog(`‚ùå GET /Timesheet - Erreur: ${error1}`, 'error');
          }
        } catch (error) {
          addDiagnosticLog(`‚ùå GET /Timesheet - Exception: ${error.message}`, 'error');
        }
        
        // Test 2: Endpoint avec scope daily
        addDiagnosticLog('üì° Test 2: GET /Timesheet/Resume/UserId/2/scope/daily', 'info');
        try {
          const response2 = await fetch(`${authManager.API_BASE_URL}/Timesheet/Resume/UserId/2/scope/daily`, {
            headers: {
              'Authorization': `Bearer ${token}`,
              'Content-Type': 'application/json'
            }
          });
          
          addDiagnosticLog(`üì° GET /Timesheet/Resume - Status: ${response2.status}`, response2.ok ? 'success' : 'error');
          
          if (response2.ok) {
            const data2 = await response2.json();
            addDiagnosticLog(`‚úÖ GET /Timesheet/Resume - ${Array.isArray(data2) ? data2.length : 1} entr√©e(s)`, 'success');
          } else {
            const error2 = await response2.text();
            addDiagnosticLog(`‚ùå GET /Timesheet/Resume - Erreur: ${error2}`, 'error');
          }
        } catch (error) {
          addDiagnosticLog(`‚ùå GET /Timesheet/Resume - Exception: ${error.message}`, 'error');
        }
        
      } catch (error) {
        addDiagnosticLog(`‚ùå Erreur test Timesheet: ${error.message}`, 'error');
      }
    }

    // Fonction pour diagnostiquer la structure des donn√©es Timesheet
    async function diagnoseTimesheetData() {
      addDiagnosticLog('üîç Diagnostic de la structure des donn√©es Timesheet...', 'info');
      
      try {
        const response = await fetch(`${authManager.API_BASE_URL}/Timesheet`, {
          headers: {
            'Authorization': `Bearer ${authManager.getToken()}`,
            'Content-Type': 'application/json'
          }
        });

        if (response.ok) {
          const data = await response.json();
          addDiagnosticLog(`‚úÖ ${data.length} entr√©es r√©cup√©r√©es`, 'success');
          
          // Analyser les premiers √©l√©ments pour comprendre la structure
          if (data.length > 0) {
            const firstEntry = data[0];
            addDiagnosticLog('üìã Structure de la premi√®re entr√©e:', 'info');
            addDiagnosticLog(`   - ID: ${firstEntry.id}`, 'info');
            addDiagnosticLog(`   - Code: ${firstEntry.code}`, 'info');
            addDiagnosticLog(`   - UserId: ${firstEntry.userId}`, 'info');
            addDiagnosticLog(`   - CreatedBy: ${firstEntry.createdBy}`, 'info');
            addDiagnosticLog(`   - UserName: ${firstEntry.userName}`, 'info');
            addDiagnosticLog(`   - UserEmail: ${firstEntry.userEmail}`, 'info');
            addDiagnosticLog(`   - TimesheetTypeId: ${firstEntry.timesheetTypeId}`, 'info');
            addDiagnosticLog(`   - Start: ${firstEntry.start}`, 'info');
            
            // Chercher des entr√©es avec diff√©rents crit√®res
            const currentUser = authManager.getUser();
            const userEmail = currentUser?.email;
            
            // Recherche par email
            const entriesByEmail = data.filter(entry => 
              entry.userEmail === userEmail || 
              entry.userName === userEmail ||
              entry.code?.includes(userEmail)
            );
            
            // Recherche par ID utilisateur
            const entriesById = data.filter(entry => 
              entry.userId === currentUser?.id ||
              entry.createdBy === currentUser?.id
            );
            
            addDiagnosticLog(`üîç Recherche pour: ${userEmail}`, 'info');
            addDiagnosticLog(`   - Entr√©es par email: ${entriesByEmail.length}`, 'info');
            addDiagnosticLog(`   - Entr√©es par ID: ${entriesById.length}`, 'info');
            
            // Afficher quelques exemples d'entr√©es
            if (data.length > 0) {
              addDiagnosticLog('üìã Exemples d\'entr√©es (premi√®res 3):', 'info');
              for (let i = 0; i < Math.min(3, data.length); i++) {
                const entry = data[i];
                addDiagnosticLog(`   ${i + 1}. ID:${entry.id}, UserId:${entry.userId}, Email:${entry.userEmail}, Code:${entry.code}`, 'info');
              }
            }
            
            // Si aucune entr√©e trouv√©e, sugg√©rer de cr√©er une entr√©e de test
            if (entriesByEmail.length === 0 && entriesById.length === 0) {
              addDiagnosticLog('‚ö†Ô∏è Aucune entr√©e trouv√©e pour cet utilisateur', 'warning');
              addDiagnosticLog('üí° Suggestion: Scannez un QR code pour cr√©er votre premi√®re entr√©e', 'info');
            }
          }
        } else {
          const errorText = await response.text();
          addDiagnosticLog(`‚ùå Erreur r√©cup√©ration donn√©es: ${errorText}`, 'error');
        }
        
      } catch (error) {
        addDiagnosticLog(`‚ùå Erreur diagnostic: ${error.message}`, 'error');
      }
    }

    // Fonction pour nettoyer l'historique et ne garder que les entr√©es de l'utilisateur connect√©
    function cleanUserHistory() {
      const currentUser = authManager.getUser();
      const userEmail = currentUser?.email;
      
      addDiagnosticLog(`üßπ Nettoyage AGGRESSIF de l'historique pour: ${userEmail}`, 'info');
      
      const originalCount = pointageHistory.length;
      
      // Filtrer l'historique local - SEULEMENT les entr√©es de l'utilisateur connect√©
      pointageHistory = pointageHistory.filter(entry => {
        const entryCode = entry.code || '';
        const entryDetails = entry.details || '';
        
        // Analyser le contenu pour extraire l'utilisateur
        let codeUserEmail = null;
        let isUserEntry = false;
        
        try {
          // Essayer de parser les d√©tails comme JSON
          if (entryDetails.includes('{') && entryDetails.includes('}')) {
            const detailsData = JSON.parse(entryDetails);
            codeUserEmail = detailsData.un || detailsData.userName || detailsData.email;
            
            // V√©rifier si c'est l'utilisateur connect√©
            isUserEntry = codeUserEmail === userEmail;
          }
        } catch (e) {
          // Si ce n'est pas du JSON, chercher des patterns d'email
          const emailMatch = entryDetails.match(/[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}/);
          if (emailMatch) {
            codeUserEmail = emailMatch[0];
            isUserEntry = codeUserEmail === userEmail;
          }
        }
        
        // V√©rifications suppl√©mentaires
        if (!isUserEntry) {
          isUserEntry = entryCode.includes(userEmail) ||
                       entryCode.includes('TEST') ||
                       entryCode.includes('QR_');
        }
        
        if (!isUserEntry) {
          addDiagnosticLog(`üóëÔ∏è SUPPRESSION: ${entryCode} (utilisateur d√©tect√©: ${codeUserEmail})`, 'warning');
        } else {
          addDiagnosticLog(`‚úÖ CONSERVATION: ${entryCode} (utilisateur: ${codeUserEmail})`, 'success');
        }
        
        return isUserEntry;
      });
      
      const newCount = pointageHistory.length;
      addDiagnosticLog(`‚úÖ Historique nettoy√©: ${originalCount} ‚Üí ${newCount} entr√©es`, 'success');
      
      // Sauvegarder l'historique nettoy√©
      saveHistoryToStorage();
      updateHistoryDisplay();
      
      // Vider aussi le localStorage pour √©viter les conflits
      localStorage.removeItem('pointageHistory');
      localStorage.setItem('pointageHistory', JSON.stringify(pointageHistory));
      
      addDiagnosticLog('üíæ Historique sauvegard√© et localStorage nettoy√©', 'success');
    }

    // Fonction pour vider compl√®tement l'historique
    function clearAllHistory() {
      addDiagnosticLog('üóëÔ∏è VIDAGE COMPLET de l\'historique...', 'warning');
      
      // Vider l'historique local
      pointageHistory = [];
      
      // Vider le localStorage
      localStorage.removeItem('pointageHistory');
      
      // Mettre √† jour l'affichage
      updateHistoryDisplay();
      
      addDiagnosticLog('‚úÖ Historique compl√®tement vid√©', 'success');
    }

    // Fonction pour forcer le nettoyage complet - SEULEMENT Test@test.com
    function forceCleanTestUserHistory() {
      const currentUser = authManager.getUser();
      const userEmail = currentUser?.email;
      
      addDiagnosticLog(`üßπ NETTOYAGE FORC√â pour: ${userEmail}`, 'warning');
      
      const originalCount = pointageHistory.length;
      
      // Filtrer SEULEMENT les entr√©es de Test@test.com
      pointageHistory = pointageHistory.filter(entry => {
        const entryCode = entry.code || '';
        const entryDetails = entry.details || '';
        
        // Analyser le contenu pour extraire l'utilisateur
        let codeUserEmail = null;
        
        try {
          // Essayer de parser les d√©tails comme JSON
          if (entryDetails.includes('{') && entryDetails.includes('}')) {
            const detailsData = JSON.parse(entryDetails);
            codeUserEmail = detailsData.un || detailsData.userName || detailsData.email;
          }
        } catch (e) {
          // Si ce n'est pas du JSON, chercher des patterns d'email
          const emailMatch = entryDetails.match(/[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}/);
          if (emailMatch) {
            codeUserEmail = emailMatch[0];
          }
        }
        
        // V√©rifier si c'est Test@test.com OU un code de test
        const isTestUser = codeUserEmail === 'Test@test.com' || 
                          codeUserEmail === 'test' ||
                          entryCode.includes('TEST') ||
                          entryCode.includes('VERCEL_TEST');
        
        if (isTestUser) {
          addDiagnosticLog(`‚úÖ CONSERVATION: ${entryCode} (utilisateur: ${codeUserEmail})`, 'success');
        } else {
          addDiagnosticLog(`üóëÔ∏è SUPPRESSION: ${entryCode} (utilisateur: ${codeUserEmail})`, 'warning');
        }
        
        return isTestUser;
      });
      
      const newCount = pointageHistory.length;
      addDiagnosticLog(`‚úÖ Historique nettoy√©: ${originalCount} ‚Üí ${newCount} entr√©es`, 'success');
      
      // Sauvegarder l'historique nettoy√©
      saveHistoryToStorage();
      updateHistoryDisplay();
      
      // Vider aussi le localStorage pour √©viter les conflits
      localStorage.removeItem('pointageHistory');
      localStorage.setItem('pointageHistory', JSON.stringify(pointageHistory));
      
      addDiagnosticLog('üíæ Historique sauvegard√© et localStorage nettoy√©', 'success');
    }

    // Fonction pour tester avec diff√©rents utilisateurs de la BD
    async function testWithDifferentUsers() {
      addDiagnosticLog('üß™ Test avec diff√©rents utilisateurs de la BD...', 'info');
      
      // Liste d'utilisateurs trouv√©s dans les logs
      const testUsers = [
        { email: 'toto.mulumba@gmail.com', password: 'test123', name: 'Toto Mulumba' },
        { email: 'Stephane Banza Mutamba', password: 'test123', name: 'Stephane Banza' },
        { email: 'MUSIANI OMEYAKA JACKSON', password: 'test123', name: 'Musiani Jackson' },
        { email: 'test@test.com', password: 'test123', name: 'Test User' }
      ];
      
      addDiagnosticLog('üìã Utilisateurs de test disponibles:', 'info');
      testUsers.forEach((user, index) => {
        addDiagnosticLog(`${index + 1}. ${user.name} (${user.email})`, 'info');
      });
      
      // Test avec le premier utilisateur (toto.mulumba@gmail.com)
      addDiagnosticLog('üîç Test avec toto.mulumba@gmail.com...', 'info');
      
      try {
        const response = await fetch(`${authManager.API_BASE_URL}/Auth/login`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({
            email: 'toto.mulumba@gmail.com',
            password: 'test123'
          })
        });
        
        if (response.ok) {
          const data = await response.json();
          addDiagnosticLog(`‚úÖ Connexion r√©ussie pour toto.mulumba@gmail.com`, 'success');
          addDiagnosticLog(`   Token: ${data.token ? 'Pr√©sent' : 'Absent'}`, 'info');
          addDiagnosticLog(`   User ID: ${data.id || data.userId || 'Non d√©fini'}`, 'info');
          
          // Tester la r√©cup√©ration de l'historique
          const historyResponse = await fetch(`${authManager.API_BASE_URL}/Timesheet`, {
            headers: {
              'Authorization': `Bearer ${data.token}`,
              'Content-Type': 'application/json'
            }
          });
          
          if (historyResponse.ok) {
            const historyData = await historyResponse.json();
            addDiagnosticLog(`‚úÖ ${historyData.length} entr√©es trouv√©es pour toto.mulumba@gmail.com`, 'success');
            
            // Filtrer les entr√©es de cet utilisateur
            const userEntries = historyData.filter(entry => {
              const entryCode = entry.code || '';
              const entryDetails = entry.details || '';
              return entryCode.includes('toto.mulumba@gmail.com') || 
                     entryDetails.includes('toto.mulumba@gmail.com');
            });
            
            addDiagnosticLog(`üîç ${userEntries.length} entr√©es filtr√©es pour toto.mulumba@gmail.com`, 'info');
            
            if (userEntries.length > 0) {
              addDiagnosticLog('üìã Exemples d\'entr√©es de toto.mulumba@gmail.com:', 'info');
              userEntries.slice(0, 3).forEach((entry, index) => {
                addDiagnosticLog(`   ${index + 1}. ID:${entry.id}, Code:${entry.code}, Start:${entry.start}`, 'info');
              });
            }
          } else {
            addDiagnosticLog(`‚ùå Erreur r√©cup√©ration historique: ${await historyResponse.text()}`, 'error');
          }
          
        } else {
          const errorText = await response.text();
          addDiagnosticLog(`‚ùå √âchec connexion toto.mulumba@gmail.com: ${errorText}`, 'error');
        }
        
      } catch (error) {
        addDiagnosticLog(`‚ùå Erreur test utilisateur: ${error.message}`, 'error');
      }
    }

    // Fonction pour tester avec Stephane Banza Mutamba
    async function testStephaneUser() {
      addDiagnosticLog('üß™ Test avec Stephane Banza Mutamba...', 'info');
      
      try {
        // Test de connexion avec Stephane Banza Mutamba
        const response = await fetch(`${authManager.API_BASE_URL}/Auth/login`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({
            email: 'Stephane Banza Mutamba',
            password: 'test123'
          })
        });
        
        if (response.ok) {
          const data = await response.json();
          addDiagnosticLog(`‚úÖ Connexion r√©ussie pour Stephane Banza Mutamba`, 'success');
          addDiagnosticLog(`   Token: ${data.token ? 'Pr√©sent' : 'Absent'}`, 'info');
          addDiagnosticLog(`   User ID: ${data.id || data.userId || 'Non d√©fini'}`, 'info');
          addDiagnosticLog(`   UserName: ${data.userName || 'Non d√©fini'}`, 'info');
          
          // Tester la r√©cup√©ration de l'historique
          const historyResponse = await fetch(`${authManager.API_BASE_URL}/Timesheet`, {
            headers: {
              'Authorization': `Bearer ${data.token}`,
              'Content-Type': 'application/json'
            }
          });
          
          if (historyResponse.ok) {
            const historyData = await historyResponse.json();
            addDiagnosticLog(`‚úÖ ${historyData.length} entr√©es trouv√©es dans la BD`, 'success');
            
            // Filtrer les entr√©es de Stephane Banza Mutamba
            const stephaneEntries = historyData.filter(entry => {
              const entryCode = entry.code || '';
              const entryDetails = entry.details || '';
              return entryCode.includes('Stephane') || 
                     entryDetails.includes('Stephane') ||
                     entryDetails.includes('Banza') ||
                     entryDetails.includes('Mutamba');
            });
            
            addDiagnosticLog(`üîç ${stephaneEntries.length} entr√©es filtr√©es pour Stephane Banza Mutamba`, 'info');
            
            if (stephaneEntries.length > 0) {
              addDiagnosticLog('üìã Exemples d\'entr√©es de Stephane Banza Mutamba:', 'info');
              stephaneEntries.slice(0, 5).forEach((entry, index) => {
                addDiagnosticLog(`   ${index + 1}. ID:${entry.id}, Code:${entry.code}, Start:${entry.start}`, 'info');
              });
            } else {
              addDiagnosticLog('‚ö†Ô∏è Aucune entr√©e trouv√©e pour Stephane Banza Mutamba', 'warning');
            }
            
            // Afficher quelques exemples d'entr√©es de la BD
            addDiagnosticLog('üìã Exemples d\'entr√©es de la BD (premi√®res 5):', 'info');
            historyData.slice(0, 5).forEach((entry, index) => {
              addDiagnosticLog(`   ${index + 1}. ID:${entry.id}, Code:${entry.code}, UserId:${entry.userId}, CreatedBy:${entry.createdBy}`, 'info');
            });
            
          } else {
            const errorText = await historyResponse.text();
            addDiagnosticLog(`‚ùå Erreur r√©cup√©ration historique: ${errorText}`, 'error');
          }
          
        } else {
          const errorText = await response.text();
          addDiagnosticLog(`‚ùå √âchec connexion Stephane Banza Mutamba: ${errorText}`, 'error');
          
          // Essayer avec d'autres formats
          addDiagnosticLog('üîÑ Essai avec d\'autres formats...', 'info');
          
          const alternativeResponse = await fetch(`${authManager.API_BASE_URL}/Auth/login`, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json'
            },
            body: JSON.stringify({
              email: 'stephane.banza@test.com',
              password: 'test123'
            })
          });
          
          if (alternativeResponse.ok) {
            addDiagnosticLog('‚úÖ Connexion r√©ussie avec email alternatif', 'success');
          } else {
            addDiagnosticLog('‚ùå √âchec connexion avec email alternatif', 'error');
          }
        }
        
      } catch (error) {
        addDiagnosticLog(`‚ùå Erreur test Stephane: ${error.message}`, 'error');
      }
    }

    // Fonction pour tester la connexion avec les vrais identifiants
    async function testRealUserCredentials() {
      addDiagnosticLog('üîê Test avec les vrais identifiants...', 'info');
      
      // Liste des identifiants possibles bas√©s sur les donn√©es trouv√©es
      const testCredentials = [
        { email: 'test@test.com', password: 'test123', name: 'Test User' },
        { email: 'Test@test.com', password: 'test123', name: 'Test User (Majuscule)' },
        { email: 'toto.mulumba@gmail.com', password: 'test123', name: 'Toto Mulumba' },
        { email: 'stephane.banza@test.com', password: 'test123', name: 'Stephane Banza' },
        { email: 'musiani.jackson@test.com', password: 'test123', name: 'Musiani Jackson' }
      ];
      
      for (let i = 0; i < testCredentials.length; i++) {
        const cred = testCredentials[i];
        addDiagnosticLog(`üß™ Test ${i + 1}/${testCredentials.length}: ${cred.name} (${cred.email})`, 'info');
        
        try {
          const response = await fetch(`${authManager.API_BASE_URL}/Auth/login`, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json'
            },
            body: JSON.stringify({
              email: cred.email,
              password: cred.password
            })
          });
          
          if (response.ok) {
            const data = await response.json();
            addDiagnosticLog(`‚úÖ SUCC√àS! ${cred.name} - Token: ${data.token ? 'Pr√©sent' : 'Absent'}`, 'success');
            addDiagnosticLog(`   User ID: ${data.id || data.userId || 'Non d√©fini'}`, 'info');
            addDiagnosticLog(`   UserName: ${data.userName || 'Non d√©fini'}`, 'info');
            
            // Test de l'historique avec ce token
            const historyResponse = await fetch(`${authManager.API_BASE_URL}/Timesheet`, {
              headers: {
                'Authorization': `Bearer ${data.token}`,
                'Content-Type': 'application/json'
              }
            });
            
            if (historyResponse.ok) {
              const historyData = await historyResponse.json();
              addDiagnosticLog(`   üìä ${historyData.length} entr√©es dans la BD`, 'info');
            }
            
            break; // Arr√™ter apr√®s le premier succ√®s
          } else {
            const errorText = await response.text();
            addDiagnosticLog(`‚ùå √âchec: ${errorText}`, 'error');
          }
          
        } catch (error) {
          addDiagnosticLog(`‚ùå Erreur: ${error.message}`, 'error');
        }
        
        // Pause entre les tests
        await new Promise(resolve => setTimeout(resolve, 1000));
      }
    }

    // Fonction pour corriger l'affichage de l'historique existant
    function fixHistoryDisplay() {
      addDiagnosticLog('üîß Correction de l\'affichage de l\'historique...', 'info');
      
      const originalCount = pointageHistory.length;
      
      // Corriger chaque entr√©e
      pointageHistory = pointageHistory.map((entry, index) => {
        // D√©terminer le type bas√© sur les d√©tails JSON
        let type = 'üü¢ Entr√©e';
        try {
          const details = JSON.parse(entry.details);
          const timeSheetTypeId = details.timeSheetTypeId;
          const pid = details.pid;
          
          // Logique pour d√©terminer le type
          if (timeSheetTypeId === 2 || timeSheetTypeId === 3 || timeSheetTypeId === 6 || timeSheetTypeId === 8 || timeSheetTypeId === 9) {
            type = 'üî¥ Sortie';
          } else if (pid === 6 || pid === 8 || pid === 9 || pid === 10) {
            type = 'üî¥ Sortie';
          } else if (index % 2 === 1) {
            // Alternance si pas d'indication claire
            type = 'üî¥ Sortie';
          }
        } catch (e) {
          // Si pas de JSON, utiliser l'alternance
          type = index % 2 === 0 ? 'üü¢ Entr√©e' : 'üî¥ Sortie';
        }
        
        return {
          ...entry,
          type: type,
          status: '‚úÖ Succ√®s' // Toujours marquer comme succ√®s
        };
      });
      
      addDiagnosticLog(`‚úÖ Historique corrig√©: ${originalCount} entr√©es mises √† jour`, 'success');
      
      // Sauvegarder et mettre √† jour l'affichage
      saveHistoryToStorage();
      updateHistoryDisplay();
    }

    // Fonction pour forcer la correction compl√®te de l'historique
    function forceFixHistoryDisplay() {
      addDiagnosticLog('üîß FOR√áAGE de la correction de l\'historique...', 'warning');
      
      // Vider compl√®tement l'historique
      pointageHistory = [];
      localStorage.removeItem('pointageHistory');
      
      addDiagnosticLog('üóëÔ∏è Historique vid√©, rechargement depuis la BD...', 'info');
      
      // Recharger depuis la base de donn√©es
      loadHistoryFromDatabase();
      
      addDiagnosticLog('‚úÖ Rechargement forc√© termin√©', 'success');
    }

    // Fonction pour nettoyer les entr√©es d'autres utilisateurs
    function cleanOtherUsersEntries() {
      const currentUser = authManager.getUser();
      const userEmail = currentUser?.email;
      const userId = currentUser?.id;
      
      addDiagnosticLog(`üßπ Nettoyage des entr√©es d'autres utilisateurs pour: ${userEmail}`, 'warning');
      
      const originalCount = pointageHistory.length;
      
      // Filtrer SEULEMENT les entr√©es de l'utilisateur connect√©
      pointageHistory = pointageHistory.filter(entry => {
        const entryCode = entry.code || '';
        const entryDetails = entry.details || '';
        
        // Analyser le contenu pour extraire l'utilisateur
        let codeUserEmail = null;
        let codeUserId = null;
        
        try {
          // Essayer de parser les d√©tails comme JSON
          if (entryDetails.includes('{') && entryDetails.includes('}')) {
            const detailsData = JSON.parse(entryDetails);
            codeUserEmail = detailsData.un || detailsData.userName || detailsData.email;
            codeUserId = detailsData.uid || detailsData.userId;
          }
        } catch (e) {
          // Si ce n'est pas du JSON, chercher des patterns d'email
          const emailMatch = entryDetails.match(/[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}/);
          if (emailMatch) {
            codeUserEmail = emailMatch[0];
          }
        }
        
        // V√©rification STRICTE : l'entr√©e appartient-elle √† l'utilisateur connect√© ?
        const isUserEntry = codeUserEmail === userEmail || 
                           codeUserId === userId ||
                           codeUserId === userEmail ||
                           entryCode.includes(userEmail);
        
        if (isUserEntry) {
          addDiagnosticLog(`‚úÖ CONSERVATION: ${entryCode} (utilisateur: ${codeUserEmail})`, 'success');
        } else {
          addDiagnosticLog(`üóëÔ∏è SUPPRESSION: ${entryCode} (utilisateur: ${codeUserEmail})`, 'warning');
        }
        
        return isUserEntry;
      });
      
      const newCount = pointageHistory.length;
      addDiagnosticLog(`‚úÖ Nettoyage termin√©: ${originalCount} ‚Üí ${newCount} entr√©es`, 'success');
      
      // Sauvegarder l'historique nettoy√©
      saveHistoryToStorage();
      updateHistoryDisplay();
    }

    // Fonction pour charger seulement les entr√©es locales (RAPIDE)
    function loadLocalHistoryOnly() {
      addDiagnosticLog('üì• Chargement RAPIDE - Entr√©es locales seulement...', 'info');
      
      // Charger depuis localStorage seulement
      const storedHistory = localStorage.getItem('pointageHistory');
      if (storedHistory) {
        try {
          pointageHistory = JSON.parse(storedHistory);
          addDiagnosticLog(`‚úÖ ${pointageHistory.length} entr√©es charg√©es depuis le stockage local`, 'success');
          updateHistoryDisplay();
        } catch (e) {
          addDiagnosticLog('‚ùå Erreur chargement historique local', 'error');
          pointageHistory = [];
        }
      } else {
        addDiagnosticLog('‚ÑπÔ∏è Aucun historique local trouv√©', 'info');
        pointageHistory = [];
        updateHistoryDisplay();
      }
    }

    // Fonction pour cr√©er une entr√©e de test pour Test@test.com
    async function createTestEntry() {
      addDiagnosticLog('üß™ Cr√©ation d\'une entr√©e de test pour Test@test.com...', 'info');
      
      try {
        // Donn√©es de test optimis√©es
        const testData = {
          code: "TEST_ENTRY_" + Date.now(),
          details: JSON.stringify({
            uid: 2,
            un: "Test@test.com",
            pid: 5,
            ts: Date.now(),
            lat: -11.6703745,
            lng: 27.484246999999996,
            timeSheetTypeId: 1
          }),
          start: new Date().toISOString(),
          planningId: 5,
          timesheetTypeId: 1
        };
        
        addDiagnosticLog(`üì§ Envoi des donn√©es: ${JSON.stringify(testData)}`, 'info');
        
        const response = await fetch(`${authManager.API_BASE_URL}/Timesheet`, {
          method: 'POST',
          headers: {
            'Authorization': `Bearer ${authManager.getToken()}`,
            'Content-Type': 'application/json'
          },
          body: JSON.stringify(testData)
        });
        
        if (response.ok) {
          const result = await response.json();
          addDiagnosticLog(`‚úÖ Entr√©e de test cr√©√©e avec succ√®s! ID: ${result.id}`, 'success');
          addDiagnosticLog(`üìä R√©ponse API: ${JSON.stringify(result)}`, 'info');
          
          // Ajouter √† l'historique local
          const newEntry = {
            timestamp: new Date(testData.start),
            code: testData.code,
            details: testData.details,
            type: 'üü¢ Entr√©e',
            hours: '-',
            status: '‚úÖ Succ√®s',
            apiResponse: result
          };
          
          pointageHistory.unshift(newEntry);
          saveHistoryToStorage();
          updateHistoryDisplay();
          
          addDiagnosticLog('‚úÖ Entr√©e ajout√©e √† l\'historique local', 'success');
          addDiagnosticLog(`üìä Historique mis √† jour: ${pointageHistory.length} entr√©es`, 'info');
          
        } else {
          const errorText = await response.text();
          addDiagnosticLog(`‚ùå Erreur cr√©ation entr√©e: ${errorText}`, 'error');
        }
        
      } catch (error) {
        addDiagnosticLog(`‚ùå Erreur cr√©ation entr√©e: ${error.message}`, 'error');
      }
    }

    // Fonction pour tester le scanner avec un QR code simul√©
    function testScannerWithSimulatedQR() {
      addDiagnosticLog('üß™ Test du scanner avec QR code simul√©...', 'info');
      
      // Simuler un QR code pour Test@test.com
      const simulatedQRCode = JSON.stringify({
        uid: 2,
        un: "Test@test.com",
        pid: 5,
        ts: Date.now(),
        lat: -11.6703745,
        lng: 27.484246999999996,
        timeSheetTypeId: 1
      });
      
      addDiagnosticLog(`üì± QR Code simul√©: ${simulatedQRCode}`, 'info');
      
      // Parser le JSON comme le fait onScanSuccess
      let qrData;
      try {
        qrData = JSON.parse(simulatedQRCode);
        addDiagnosticLog('üìã QR code JSON pars√© avec succ√®s', 'info');
      } catch (e) {
        qrData = simulatedQRCode;
        addDiagnosticLog('üìã QR code trait√© comme texte', 'info');
      }
      
      // Appeler la fonction de validation comme si c'√©tait un vrai scan
      validatePointage(qrData, simulatedQRCode);
      
      addDiagnosticLog('‚úÖ Test du scanner termin√©', 'success');
    }

    // Fonction pour forcer le rechargement et trouver les nouvelles entr√©es
    async function forceReloadAndFindNewEntries() {
      addDiagnosticLog('üîÑ FOR√áAGE du rechargement pour trouver les nouvelles entr√©es...', 'warning');
      
      try {
        const response = await fetch(`${authManager.API_BASE_URL}/Timesheet`, {
          headers: {
            'Authorization': `Bearer ${authManager.getToken()}`,
            'Content-Type': 'application/json'
          }
        });

        if (response.ok) {
          const data = await response.json();
          addDiagnosticLog(`‚úÖ ${data.length} entr√©es r√©cup√©r√©es depuis la BD`, 'success');
          
          // Chercher les entr√©es r√©centes (derni√®res 24h)
          const now = new Date();
          const oneDayAgo = new Date(now.getTime() - 24 * 60 * 60 * 1000);
          
          const recentEntries = data.filter(entry => {
            const entryDate = new Date(entry.createdAt || entry.start);
            return entryDate > oneDayAgo;
          });
          
          addDiagnosticLog(`üìÖ ${recentEntries.length} entr√©es r√©centes (24h)`, 'info');
          
          // Filtrer pour Test@test.com
          const testUserEntries = recentEntries.filter(entry => {
            const entryCode = entry.code || '';
            const entryDetails = entry.details || '';
            
            return entryCode.includes('TEST_ENTRY') ||
                   entryDetails.includes('Test@test.com') ||
                   entryDetails.includes('test@test.com') ||
                   entry.createdBy === 1;
          });
          
          addDiagnosticLog(`üë§ ${testUserEntries.length} entr√©es trouv√©es pour Test@test.com`, 'success');
          
          if (testUserEntries.length > 0) {
            addDiagnosticLog('üìã Entr√©es trouv√©es:', 'info');
            testUserEntries.forEach((entry, index) => {
              addDiagnosticLog(`${index + 1}. ID:${entry.id}, Code:${entry.code}, Created:${entry.createdAt}`, 'info');
            });
            
            // Convertir et ajouter √† l'historique
            const convertedHistory = testUserEntries.map((entry, index) => {
              let type = index % 2 === 0 ? 'üü¢ Entr√©e' : 'üî¥ Sortie';
              
              return {
                timestamp: new Date(entry.createdAt || entry.start),
                code: entry.code || 'UNKNOWN',
                details: entry.details || JSON.stringify(entry),
                type: type,
                hours: '-',
                status: '‚úÖ Succ√®s',
                apiResponse: entry
              };
            });
            
            pointageHistory = convertedHistory;
            saveHistoryToStorage();
            updateHistoryDisplay();
            
            addDiagnosticLog(`‚úÖ ${convertedHistory.length} entr√©es ajout√©es √† l'historique`, 'success');
          }
        }
        
      } catch (error) {
        addDiagnosticLog(`‚ùå Erreur rechargement: ${error.message}`, 'error');
      }
    }

    // Fonction pour tester determinePointageType
    function testDeterminePointageType() {
      addDiagnosticLog('üß™ Test de determinePointageType...', 'info');
      
      // Test avec timeSheetTypeId = 1 (entr√©e)
      const testEntry1 = {
        code: {
          uid: 2,
          un: "Test@test.com",
          pid: 5,
          timeSheetTypeId: 1
        },
        details: JSON.stringify({
          uid: 2,
          un: "Test@test.com",
          pid: 5,
          timeSheetTypeId: 1
        })
      };
      
      const result1 = determinePointageType(testEntry1);
      addDiagnosticLog(`üìä Test 1 - timeSheetTypeId=1: ${result1}`, result1 === 'entr√©e' ? 'success' : 'error');
      
      // Test avec timeSheetTypeId = 2 (sortie)
      const testEntry2 = {
        code: {
          uid: 2,
          un: "Test@test.com",
          pid: 5,
          timeSheetTypeId: 2
        },
        details: JSON.stringify({
          uid: 2,
          un: "Test@test.com",
          pid: 5,
          timeSheetTypeId: 2
        })
      };
      
      const result2 = determinePointageType(testEntry2);
      addDiagnosticLog(`üìä Test 2 - timeSheetTypeId=2: ${result2}`, result2 === 'sortie' ? 'success' : 'error');
      
      addDiagnosticLog('‚úÖ Test de determinePointageType termin√©', 'success');
    }

    // Fonction pour tester canMakePointage avec les donn√©es actuelles
    function testCanMakePointage() {
      addDiagnosticLog('üß™ Test de canMakePointage...', 'info');
      
      const currentUserId = authManager.getUser()?.id;
      addDiagnosticLog(`üë§ Utilisateur actuel: ${currentUserId}`, 'info');
      
      const userHistory = pointageHistory.filter(entry => {
        if (entry.apiResponse && entry.apiResponse.userId) {
          return entry.apiResponse.userId === currentUserId;
        }
        return true;
      });

      addDiagnosticLog(`üìä Historique utilisateur: ${userHistory.length} entr√©es`, 'info');

      // Obtenir le dernier pointage de l'utilisateur
      const lastUserPointage = userHistory[0];
      
      if (lastUserPointage) {
        // G√©rer le cas o√π pointageType n'existe pas
        let lastPointageType = lastUserPointage.pointageType;
        if (!lastPointageType && lastUserPointage.type) {
          // Convertir le type affich√© en pointageType
          if (lastUserPointage.type.includes('Entr√©e')) {
            lastPointageType = 'entr√©e';
          } else if (lastUserPointage.type.includes('Sortie')) {
            lastPointageType = 'sortie';
          }
        }
        
        addDiagnosticLog(`üìÖ Dernier pointage: ${lastPointageType} √† ${lastUserPointage.timestamp}`, 'info');
      } else {
        addDiagnosticLog(`üìÖ Aucun pointage pr√©c√©dent trouv√©`, 'info');
      }
      
      // Tester les deux types
      const canMakeEntree = canMakePointage('entr√©e');
      const canMakeSortie = canMakePointage('sortie');
      
      addDiagnosticLog(`üß™ R√©sultats test: Entr√©e=${canMakeEntree}, Sortie=${canMakeSortie}`, 'info');
      
      return { canMakeEntree, canMakeSortie };
    }

    // Fonction pour forcer le rechargement complet de l'historique
    async function forceReloadHistory() {
      addDiagnosticLog('üîÑ FOR√áAGE du rechargement complet de l\'historique...', 'warning');
      
      // Vider compl√®tement l'historique
      pointageHistory = [];
      localStorage.removeItem('pointageHistory');
      
      addDiagnosticLog('üóëÔ∏è Historique vid√©, rechargement depuis la BD...', 'info');
      
      // Recharger depuis la base de donn√©es
      await loadHistoryFromDatabase();
      
      addDiagnosticLog('‚úÖ Rechargement forc√© termin√©', 'success');
      
      // Test de diagnostic apr√®s rechargement
      setTimeout(() => {
        testCanMakePointage();
      }, 500);
    }

    // Fonction am√©lior√©e pour mettre √† jour les statistiques
    function updateStatistics() {
      const totalPointages = pointageHistory.length;
      const successfulPointages = pointageHistory.filter(entry => entry.status === '‚úÖ Succ√®s').length;
      const errorPointages = pointageHistory.filter(entry => entry.status !== '‚úÖ Succ√®s').length;
      
      // Calculer les heures prest√©es
      let totalHours = 0;
      let sessions = 0;
      let workingDays = new Set();
      
      for (let i = 0; i < pointageHistory.length - 1; i++) {
        const current = pointageHistory[i];
        const next = pointageHistory[i + 1];
        
        if (current.pointageType === 'entr√©e' && next.pointageType === 'sortie') {
          const startTime = new Date(current.timestamp);
          const endTime = new Date(next.timestamp);
          const hours = (endTime - startTime) / (1000 * 60 * 60);
          totalHours += hours;
          sessions++;
          
          // Ajouter le jour de travail
          const workDate = startTime.toDateString();
          workingDays.add(workDate);
        }
      }
      
      // Mettre √† jour l'affichage
      const totalPointagesElement = document.getElementById('totalPointages');
      const successPointagesElement = document.getElementById('successPointages');
      const errorPointagesElement = document.getElementById('errorPointages');
      const totalHoursElement = document.getElementById('totalHours');
      const workingDaysElement = document.getElementById('workingDays');
      const sessionsElement = document.getElementById('sessions');
      const averageHoursElement = document.getElementById('averageHours');
      
      if (totalPointagesElement) totalPointagesElement.textContent = totalPointages;
      if (successPointagesElement) successPointagesElement.textContent = successfulPointages;
      if (errorPointagesElement) errorPointagesElement.textContent = errorPointages;
      if (totalHoursElement) totalHoursElement.textContent = totalHours.toFixed(1) + 'h';
      if (workingDaysElement) workingDaysElement.textContent = workingDays.size;
      if (sessionsElement) sessionsElement.textContent = sessions;
      
      // Calculer la moyenne par jour
      const averageHoursPerDay = workingDays.size > 0 ? totalHours / workingDays.size : 0;
      if (averageHoursElement) averageHoursElement.textContent = averageHoursPerDay.toFixed(1) + 'h';
      
      // Log des statistiques pour debug
      addDiagnosticLog(`üìä Statistiques mises √† jour:`, 'info');
      addDiagnosticLog(`   ‚Ä¢ Total pointages: ${totalPointages}`, 'info');
      addDiagnosticLog(`   ‚Ä¢ Succ√®s: ${successfulPointages}`, 'info');
      addDiagnosticLog(`   ‚Ä¢ Erreurs: ${errorPointages}`, 'info');
      addDiagnosticLog(`   ‚Ä¢ Heures totales: ${totalHours.toFixed(1)}h`, 'info');
      addDiagnosticLog(`   ‚Ä¢ Jours travaill√©s: ${workingDays.size}`, 'info');
      addDiagnosticLog(`   ‚Ä¢ Sessions: ${sessions}`, 'info');
    }
  </script>
  <script src="complete-validation-bypass.js"></script>
  <script src="aggressive-bypass.js"></script>
          <script src="scanner-diagnostic.js"></script>
        <script src="network-error-fix.js"></script>
    </body>
</html>

